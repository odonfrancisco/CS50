/* global define:true require:true */
/* exported define */

// Super simple require system
(function() {
    // Store our repository in private variables in this closure.
    var defs = {};
    var modules = {};

    // When the user defines a module's setup function, store it here.
    define = function define(name, fn) {
        defs[name] = defs[name] || fn;
    };

    var realRequire = global.require;
    // The first time a module is used, it's description is executed and cached.
    require = function require(name) {
        if (modules.hasOwnProperty(name)) return modules[name];
        if (defs.hasOwnProperty(name)) {
            var exports = (modules[name] = {});
            var module = {exports: exports};
            var fn = defs[name];
            fn(module, exports, innerRequire(name));
            return (modules[name] = module.exports);
        }
        if (realRequire) {
            return realRequire(name);
        }
        throw new Error("Can't find module " + name);
    };
    require.resolve = realRequire.resolve;

    function innerRequire(parentId) {
        function boundRequire(module) {
            return require(normalizeName(parentId, module));
        }
        boundRequire.resolve = realRequire.resolve;
        return boundRequire;
    }

    function normalizeName(parentId, moduleName) {
        // normalize plugin requires
        if (moduleName.indexOf("!") !== -1) {
            var chunks = moduleName.split("!");
            return normalizeName(parentId, chunks[0]) + "!" + normalizeName(parentId, chunks[1]);
        }
        // normalize relative requires
        if (moduleName.charAt(0) == ".") {
            var parentChunks = parentId.split("/");
            var parentModule = parentChunks.shift();
            if (parentModule.charAt(0) == "@") {
                parentModule = parentModule + "/" + parentChunks.shift();
            }

            var path = parentChunks.slice(0, -1).join("/");
            moduleName = parentModule + (path ? "/" + path : "") + "/" + moduleName;

            while (moduleName.indexOf(".") !== -1 && previous != moduleName) {
                var previous = moduleName;
                moduleName = moduleName.replace(/\/\.\//, "/").replace(/[^\/]+\/\.\.\//, "");
            }
        }

        return moduleName;
    }
})();


define('c9.ide.collab/server/collab-server.js', function (module, exports, require) {

"use strict";
var Fs = require("fs");
var Path = require("path");
var net = require("net");
var Stream = require("stream").Stream;
var crypto = require("crypto");
var events = require("events");
var exists = Fs.exists || Path.exists;

var localfsAPI; // Set on VFS register
var DEFAULT_NL_CHAR_FILE = "\n";
var DEFAULT_NL_CHAR_DOC = "";
var MAX_WRITE_ATTEMPTS = 3;
var DEFAULT_HOME = "/home/ubuntu";

// If you leave unsaved changes for more than 24 hours and the file on disk changes
// those unsaved changes will be lost. Don't want them hanging around forever.
var UNSAVED_CHANGE_EXPIRY_TIME = 24 * 60 * 60 * 1000;

// Models
var User, Document, Revision, Environment, ChatMessage;
var basePath;
var PID;
var dbFilePath;

// Cache the environment state got from the database
var cachedWS;
var cachedUsers;

var totalWriteAttempts = 0;
var lastFailedWrite = 0;
var resettingDatabase = false;

var isMaster = false;

var Sequelize;
var sqlite3Path;

var nodePath = getHomeDir() + "/.c9/node_modules";

var debug = false;

var logger = {
    debug: function() {
        if (!debug) {
            return;
        }

        var args = [].slice.call(arguments);

        console.log.apply(console, logger.formatLog.apply(null, ["DEBUG"].concat(args)));
    },
    info: function() {
        var args = [].slice.call(arguments);
        console.log.apply(console, logger.formatLog.apply(null, ["INFO"].concat(args)));
    },
    warn: function() {
        var args = [].slice.call(arguments);
        console.log.apply(console, logger.formatLog.apply(null, ["WARN"].concat(args)));
    },
    error: function() {
        var args = [].slice.call(arguments);

        if (args.length < 1) {
            return;
        }

        var err = args[args.length - 1];
        if (!(err instanceof Error)) {
            err = new Error(err);
        }
        if (err.path) {
            var cleanErr = new Error(
                String(err.message)
                    .split(err.path)
                    .join("")
            );
            cleanErr.code = err.code;
            cleanErr.stack = err.stack;
            err = cleanErr;
        }
        args[args.length - 1] = err;

        console.error.apply(console, logger.formatLog.apply(null, ["ERROR"].concat(args)));
    },
    formatLog: function() {
        var args = [].slice.call(arguments);
        var level = args[0] || "UNKNOWN";

        return ["[" + level + "]", "[collab-server]"].concat(args.slice(1));
    },
};

function getHomeDir() {
    return process.env.HOME || DEFAULT_HOME;
}

function getProjectWD() {
    var env = process.env;
    var pidStr = env.BASE_PROC ? "" : String(PID);
    return Path.resolve(env.BASE_PROC || env.HOME || DEFAULT_HOME, ".c9", pidStr);
}

/**
 * Checks if the collab server required modules are installed
 * npm: sqlite3 & sequelize
 */
function installServer(callback) {
    function checkNotInstalled(root) {
        try {
            sqlite3Path = require.resolve(root + "sqlite3");
            require(sqlite3Path);
            Sequelize = require(root + "sequelize");
            return;
        } catch (err) {
            return err;
        }
    }
    if (!Sequelize && checkNotInstalled(nodePath + "/") && checkNotInstalled("")) {
        var err = new Error(
            "Couldn't load node modules sqlite3 and sequelize " +
                "from " +
                nodePath +
                " " +
                "node version: " +
                process.version +
                "; " +
                "node execPath " +
                process.execPath +
                "\n" +
                checkNotInstalled(nodePath + "/") +
                "\n" +
                checkNotInstalled("")
        );
        err.code = "EFATAL";
        logger.error(err.message);
        return callback && callback(err);
    }
    callback && callback();
}

/**
 * Wrap Sequelize callback-style to NodeJS"s standard callback-style
 */
function wrapSeq(fun, next) {
    return fun.then(
        function() {
            next.apply(null, [null].concat(Array.prototype.slice.apply(arguments)));
        },
        function(err) {
            logger.error("wrapSeq failed:", err);
            checkDBCorruption(err, next);
        }
    );
}

/**
 * Check for DB corruption errors in SQL Query and if we have some then run initDB again
 **/
function checkDBCorruption(err, callback) {
    if (!err || !isMaster) {
        return callback();
    }

    var errMessage = err && err.message ? " " + err.message : "";

    // Ignore duplicate column name errors, there is no way to stop them happening in ALTER TABLE syntax
    if (errMessage.match(/duplicate column name/)) {
        return callback();
    }

    broadcast({
        type: "ERROR",
        err: new Error("Collab encountered error" + errMessage),
        collabError: err,
    });

    logger.error("CheckDBCorruption encountered error: ", err);
    if (
        err.code === "SQLITE_ERROR" ||
        err.code === "SQLITE_CORRUPT" ||
        err.code === "SQLITE_NOTADB" ||
        err.code === "SQLITE_IOERR"
    ) {
        logger.error(
            "found a corrupted database - backing up and starting with a fresh collab database",
            err
        );
        broadcast({
            type: "ERROR",
            err: new Error("Collab database corrupt"),
        });
        return resetDB(callback);
    }

    if (err.code == "SQLITE_READONLY") {
        if (lastFailedWrite < Date.now() - 5000) {
            totalWriteAttempts = 0;
        }
        totalWriteAttempts++;
        lastFailedWrite = Date.now();
        if (totalWriteAttempts >= MAX_WRITE_ATTEMPTS) {
            logger.error(
                "Failed to write " + MAX_WRITE_ATTEMPTS + " times, checking if database is corrupt",
                err
            );

            // If the database is really corrupt this should return a corruption error which will be caught above
            var sequelize = connectToDB();
            wrapSeq(sequelize.query("PRAGMA synchronous = 0;"), function() {
                if (sequelize.close) {
                    sequelize.close();
                }
            });
        }
    }

    callback(err);
}

function connectToDB() {
    dbFilePath = dbFilePath || Path.join(getProjectWD(), "collab.v3.db");
    installServer();
    var sequelize = new Sequelize("c9-collab", "c9", "c9-collab-secret", {
        // the sql dialect of the database
        dialect: "sqlite",
        dialectModulePath: sqlite3Path,
        omitNull: true,
        storage: dbFilePath,
        logging: function(log) {
            logger.debug("DB", log);
        },
        define: {
            // don"t use camelcase for automatically added attributes but underscore style
            // so updatedAt will be updated_at
            underscored: true,
            freezeTableName: false,
            charset: "utf8",
            collate: "utf8_general_ci",
            classMethods: {},
            instanceMethods: {},
        },

        // sync after each association (see below). If set to false, you need to sync manually after setting all associations. Default: true
        syncOnAssociation: true,

        // use pooling in order to reduce db connection overload and to increase speed
        // currently only for mysql and postgresql (since v1.5.0)
        pool: {
            maxConnections: 5,
            maxIdleTime: 30 * 1000,
        },
    });

    return sequelize;
}

/**
 * Initialize the collab server sqlite3 database
 *  - Define modules mapping to tables
 *  - Declare relationships
 *  - Sync sequelize modules
 *  - Create and cache the Environment metadata
 *  - Set synchronous = 0 for fastest IO performance.  NOTE: This should optimize
 *    for safety not performance, and is tracked in https://i.amazon.com/issues/AWS-Cloud9-3922
 *  - Create indices, if not existing
 *
 * @param {Boolean} readonly    Whether the intention is only to read from the
 *                              database (if true, initialization is skipped)
 * @param {Function} callback
 */
function initDB(readonly, callback) {
    var sequelize = connectToDB();

    Store.User = User = sequelize.define(
        "User",
        {
            userId: {type: Sequelize.STRING, primaryKey: true},
            name: {type: Sequelize.STRING},
        },
        {
            timestamps: true,
        }
    );

    Store.Environment = Environment = sequelize.define(
        "Environment",
        {
            authorPool: {type: Sequelize.TEXT}, // Stringified JSON  - userId -> 1,2, ...etc.
            colorPool: {type: Sequelize.TEXT}, // Stringified JSON - userId --> "{r: 256, g: 0, b: 0}"
            basePath: {type: Sequelize.STRING, allowNull: false},
            migration: {type: Sequelize.INTEGER, defaultValue: 0},
        },
        {
            timestamps: true,
        }
    );

    Store.Document = Document = sequelize.define(
        "Document",
        {
            id: {type: Sequelize.INTEGER, primaryKey: true, autoIncrement: true},
            path: {type: Sequelize.STRING, unique: true},
            contents: {type: Sequelize.TEXT},
            fsHash: {type: Sequelize.STRING},
            authAttribs: {type: Sequelize.TEXT}, // Stringified JSON
            starRevNums: {type: Sequelize.TEXT}, // Stringified JSON list of integers
            revNum: {type: Sequelize.INTEGER, defaultValue: 0},
            created_at: {type: Sequelize.DATE, allowNull: false, defaultValue: Sequelize.NOW},
            updated_at: {type: Sequelize.DATE, allowNull: false, defaultValue: Sequelize.NOW},
            lastUpdate: {type: Sequelize.BIGINT, defaultValue: 0},
            newLineChar: {type: Sequelize.STRING, defaultValue: DEFAULT_NL_CHAR_DOC}, // "" or "\n" or "\r\n"
        },
        {
            timestamps: false,
        }
    );

    Store.Revision = Revision = sequelize.define(
        "Revision",
        {
            id: {type: Sequelize.INTEGER, primaryKey: true, autoIncrement: true},
            operation: {type: Sequelize.TEXT}, // Stringified JSON Array - can be empty for rev:0
            author: {type: Sequelize.STRING}, // userId if exists, 0 in syncing operations, -1 in undo non authored text
            revNum: {type: Sequelize.INTEGER},
            created_at: {type: Sequelize.DATE, allowNull: false, defaultValue: Sequelize.NOW},
            updated_at: {type: Sequelize.DATE, allowNull: false, defaultValue: Sequelize.NOW},
        },
        {
            timestamps: false,
        }
    );

    Store.ChatMessage = ChatMessage = sequelize.define(
        "ChatMessage",
        {
            id: {type: Sequelize.INTEGER, primaryKey: true, autoIncrement: true},
            text: {type: Sequelize.STRING},
            userId: {type: Sequelize.STRING, allowNull: false},
            name: {type: Sequelize.STRING, allowNull: false},
            timestamp: {type: Sequelize.DATE, allowNull: false, defaultValue: Sequelize.NOW},
        },
        {
            timestamps: true,
        }
    );

    Document.hasMany(Revision);
    Revision.belongsTo(Document);

    if (readonly || !isMaster) return callback();

    // Add migrations here e.g. ALTER TABLE ... ADD COLUMN ...
    var migrations = [
        {query: "CREATE INDEX DocumentRevisionsIndex ON Revisions(document_id)", skipError: true},
        {
            query: "CREATE INDEX ChatMessageTimestampIndex ON ChatMessages(timestamp)",
            skipError: true,
        },
        {query: "DELETE FROM Documents"},
        {query: "DELETE FROM Revisions"},
        {query: "ALTER TABLE Documents ADD COLUMN newLineChar VARCHAR(255)"},
        {query: "ALTER TABLE Documents ADD COLUMN lastUpdate BIGINT"},
    ];

    async.series(
        [
            function(next) {
                // http://www.sqlite.org/pragma.html
                wrapSeq(sequelize.query("PRAGMA synchronous = 0;"), next);
            },
            function(next) {
                wrapSeq(User.sync(), next);
            },
            function(next) {
                wrapSeq(Environment.sync(), next);
            },
            function(next) {
                wrapSeq(Document.sync(), next);
            },
            function(next) {
                wrapSeq(Revision.sync(), next);
            },
            function(next) {
                wrapSeq(ChatMessage.sync(), next);
            },
            function(next) {
                wrapSeq(
                    Environment.findOrCreate(
                        {id: 1},
                        {
                            authorPool: "{}",
                            colorPool: "{}",
                            basePath: basePath,
                            migration: migrations.length,
                        }
                    ),
                    function(err, ws) {
                        if (err) return next(err);
                        ws.authorPoolParsed = parseJSONField(ws.authorPool);
                        ws.colorPoolParsed = parseJSONField(ws.colorPool);
                        cachedWS = ws;
                        next();
                    }
                );
            },
            function(next) {
                var migNum = cachedWS.migration || 0;
                if (migNum === migrations.length) return next();
                var migApplied = migNum;
                async.forEachSeries(
                    migrations.slice(migNum - migrations.length),
                    function(migration, next) {
                        logger.debug("applying database migration:", migration.query);
                        wrapSeq(sequelize.query(migration.query), function(err) {
                            if (err && !migration.skipError) return next(err);
                            migApplied++;
                            cachedWS.migration = migApplied;
                            Store.saveEnvironmentState(cachedWS, next);
                        });
                    },
                    function(err) {
                        if (cachedWS.migration != migrations.length)
                            err =
                                (err ? err + " -- " : "") + "Not all migrations could be applied!";
                        next(err);
                    }
                );
            },
        ],
        function(err) {
            if (err) {
                logger.error("initDB attempt failed:", err);
                return checkDBCorruption(err, callback);
            }

            callback(null, {});
        }
    );
}

// parse json encoded several times
function parseJSONField(val) {
    try {
        while (typeof val == "string") {
            val = JSON.parse(val);
        }
    } catch (e) {
        logger.error("parseJSONField failed:", e);
        val = {};
    }
    return val;
}

/**
 * Resets the database back to default state deleting all collab changes.
 * This is useful if the database somehow becomes corrupt and can no longer be written to
 **/

function resetDB(callback) {
    if (resettingDatabase || !isMaster) return callback();
    logger.warn("resetting collab database");
    resettingDatabase = true;
    Fs.rename(dbFilePath, dbFilePath + ".old", function(err) {
        if (err && err.code !== "ENOENT") {
            resettingDatabase = false;
            return callback(err);
        }

        initDB(false, function() {
            resettingDatabase = false;
            broadcast({
                type: "RESET_DB",
            });
            callback();
        });
    });
}

/**************** operations.js ******************/
var operations = (function() {
    /**
     * Get a diff operation to transform a text document from: `fromText` to `toText`
     *
     * @param {String} fromText
     * @param {String} toText
     * @return {Operation} op
     */
    function operation(fromText, toText) {
        var dmp = new diff_match_patch();
        var diffs = dmp.diff_main(fromText, toText);
        dmp.diff_cleanupSemantic(diffs);
        var d, type, val;
        var op = [];
        for (var i = 0; i < diffs.length; i++) {
            d = diffs[i];
            type = d[0];
            val = d[1];
            switch (type) {
                case DIFF_EQUAL:
                    op.push("r" + val.length);
                    break;
                case DIFF_INSERT:
                    op.push("i" + val);
                    break;
                case DIFF_DELETE:
                    op.push("d" + val);
                    break;
                default:
                    throw new Error("Unkown operation: " + type);
            }
        }
        return op;
    }

    // Simple edit constructors.

    function insert(chars) {
        return "i" + chars;
    }

    function del(chars) {
        return "d" + chars;
    }

    function retain(n) {
        return "r" + String(n);
    }

    /**
     * Return the type of a sub-edit
     *
     * @param  {String} edit
     * @return {String} type of the operation
     */
    function type(edit) {
        switch (edit[0]) {
            case "r":
                return "retain";
            case "d":
                return "delete";
            case "i":
                return "insert";
            default:
                throw new TypeError("Unknown type of edit: ", edit);
        }
    }

    /**
     * Return the value of a sub-edit
     *
     * @param  {String} sub-edit
     * @return the value of the operation
     *   - Retain: the number of characters to retain
     *   - Insert/Delete: the text to insert or delete
     */
    function val(edit) {
        return type(edit) === "retain" ? ~~edit.slice(1) : edit.slice(1);
    }

    /**
     * Return the length of a sub-edit
     *
     * @param  {String} edit
     * @return {Number} the length of the operation
     *   - Retain: the number of characters to retain
     *   - Insert/Delete: the text length to insert or delete
     */
    function length(edit) {
        return type(edit) === "retain" ? ~~edit.slice(1) : edit.length - 1;
    }

    /**
     * Split a sub-edit on a index: idx
     *
     * @param  {String} edit
     * @return [{String}] an array of length 2 of the sub-operaion splitted to 2 operaions
     */
    function split(edit, idx) {
        if (type(edit) === "retain") {
            var rCount = ~~edit.slice(1);
            return ["r" + idx, "r" + (rCount - idx)];
        } else {
            return [edit[0] + edit.substring(1, idx + 1), edit[0] + edit.substring(idx + 1)];
        }
    }

    /**
     * Pack an operation to a minimal operation
     *
     * @param  {Operation} op
     * @return {Operation} packed
     */
    function pack(op) {
        var packed = op.slice();
        var i = 0;
        while (i < packed.length - 1) {
            if (packed[i][0] === packed[i + 1][0])
                packed.splice(i, 2, packed[i][0] + (val(packed[i]) + val(packed[i + 1])));
            else i++;
        }
        return packed;
    }

    /**
     * Inverse an operation to undo revert its effect on a document
     *
     * @param  {Operation} op
     * @return {Operation} inversed
     */
    function inverse(op) {
        var edit;
        var t;
        var v;
        var inversed = new Array(op.length);
        for (var i = 0, el = op.length; i < el; i++) {
            edit = op[i];
            t = type(edit);
            v = val(edit);
            switch (t) {
                case "retain":
                    inversed[i] = op[i];
                    break;
                case "insert":
                    inversed[i] = del(v);
                    break;
                case "delete":
                    inversed[i] = insert(v);
                    break;
                default:
                    throw new Error("Unknown operation: " + op);
            }
        }
        return inversed;
    }

    return {
        insert: insert,
        del: del,
        retain: retain,
        type: type,
        val: val,
        length: length,
        split: split,
        pack: pack,
        operation: operation,
        inverse: inverse,
    };
})();

/**************** apply.js ******************/

function OTError(expected, actual) {
    var err = new Error("OT removed text mismatch");
    err.expected = expected;
    err.actual = actual;
    err.code = "EMISMATCH";
    return err;
}

/**
 * Apply an operation on a string document and return the resulting new document text.
 *
 * @param  {Opeartion} op - e.g. ["r2", "iabc", "r12"]
 * @param  {String} doc
 * @return {String} newDoc
 */
function applyContents(op, doc) {
    var val;
    var newDoc = "";
    for (var i = 0, len = op.length; i < len; i += 1) {
        val = op[i].slice(1);
        switch (op[i][0]) {
            case "r": // retain
                val = Number(val);
                newDoc += doc.slice(0, val);
                doc = doc.slice(val);
                break;
            case "i": // insert
                newDoc += val;
                break;
            case "d": // delete
                if (doc.indexOf(val) !== 0) throw new OTError(val, doc.slice(0, 10));
                else doc = doc.slice(val.length);
                break;
            default:
                throw new TypeError("Unknown operation: " + operations.type(op[i]));
        }
    }
    return newDoc;
}

/**************** author_attributes.js ******************/
/**
 * This is a specifically designed data structure that tends to behave as a relaxed B-Tree
 * to optimize author attributes processing time, disk usage and network overhead
 *
 * It optimizes on two main factors:
 * - insert/delete/traversal/find time: The B-tree try to maintain a minimal depth, so minimal processing needed for those operations: O(log with base minKeySize)
 * - Parsing/Stringification time and disk usage: the nodes are implemented as arrays with the first element
 *     indicating the number of entries in the node
 *
 * @param minKeySize - the minimum number of entries in a node
 * @param maxKeySize - the maximum number of entries in a node
 *
 * @author Mostafa
 * @author Harutyun
 */
function AuthorAttributes(minKeySize, maxKeySize) {
    // 2 * x ---> [length, [value]]
    minKeySize = minKeySize || 20; // 4
    maxKeySize = maxKeySize || 5 * minKeySize; // 8

    function addValue(nodes, index, startI, length, id) {
        var i = startI;
        var len = nodes[i];
        var val = nodes[i + 1];
        if (index < 0 || index > len) throw new Error("Invalid index passed!");

        if (val === id) {
            nodes[i] += length;
        } else if (index === len) {
            if (nodes[i + 3] == id) nodes[i + 2] += length;
            else nodes.splice(i + 2, 0, length, id);
        } else if (index === 0) {
            if (nodes[i - 1] == id) nodes[i - 2] += length;
            else nodes.splice(i, 0, length, id);
        } else {
            nodes.splice(i, 2, index, val, length, id, len - index, val);
        }
    }

    function split(parent, nodes, pos) {
        var splitPos = (nodes.length >> 2) << 1;
        var leftLen = 0;
        var rightLen = 0;
        var right = nodes.splice(splitPos, splitPos + 2);

        for (var i = 0; i < right.length; i += 2) rightLen += right[i];

        if (parent) {
            parent.splice(pos + 2, 0, rightLen, right);
            parent[pos] -= rightLen;
        } else {
            var left = nodes.splice(0, splitPos + 2);
            for (var j = 0; j < left.length; j += 2) leftLen += left[j];
            nodes.push(leftLen, left, rightLen, right);
        }
    }

    function insert(nodes, index, length, id) {
        if (nodes.length === 0) {
            nodes.push(length, id);
            return;
        }
        var spilled = _insert(nodes, index, length, id);
        if (spilled) split(null, nodes, null);
        // sanityCheck(nodes)
    }

    function _insert(nodes, index, length, id) {
        for (var i = 0; i < nodes.length; i += 2) {
            var len = nodes[i];
            if (index <= len) {
                var node = nodes[i + 1];
                if (Array.isArray(node)) {
                    nodes[i] += length;
                    var spilled = _insert(node, index, length, id);
                    if (spilled) split(nodes, nodes[i + 1], i);
                } else {
                    addValue(nodes, index, i, length, id);
                }
                return nodes.length > maxKeySize;
            }
            index -= len;
        }
    }

    function remove(nodes, index, length) {
        var removedTotal = 0;
        for (var i = 0; i < nodes.length; i += 2) {
            var len = nodes[i]; // node.length
            var ch = nodes[i + 1];
            var removed;
            if (index <= len) {
                if (Array.isArray(ch)) removed = remove(ch, index, length);
                else removed = Math.max(0, Math.min(length, len - index));

                nodes[i] -= removed; // node.length
                length -= removed;
                removedTotal += removed;
                if (!nodes[i]) {
                    nodes.splice(i, 2);
                    i -= 2;
                } else if (
                    Array.isArray(ch) &&
                    ch.length < minKeySize &&
                    ch.length + nodes.length <= maxKeySize
                ) {
                    // Move elements from child to parent
                    nodes.splice.apply(nodes, [i, 2].concat(ch));
                }
                if (!length) break;
                index = 0;
            } else {
                index -= len;
            }
        }

        for (var j = 0; j < nodes.length - 2; j += 2) {
            if (!nodes[j] || nodes[j + 1] !== nodes[j + 3]) continue;
            nodes[j] += nodes[j + 2];
            nodes.splice(j + 1, 2);
            j -= 2;
        }
        // sanityCheck(nodes);
        return removedTotal;
    }

    function apply(nodes, op, authPoolId) {
        authPoolId = authPoolId || 0;

        var index = 0;
        var opLen;
        for (var i = 0; i < op.length; i++) {
            opLen = operations.length(op[i]);
            switch (operations.type(op[i])) {
                case "retain":
                    index += opLen;
                    break;
                case "insert":
                    insert(nodes, index, opLen, authPoolId);
                    index += opLen;
                    break;
                case "delete":
                    remove(nodes, index, opLen);
                    break;
                default:
                    throw new TypeError("Unknown operation: " + operations.type(op[i]));
            }
        }
    }

    return {
        apply: apply,
        // insert: insert,
        // remove: remove
    };
}

var applyAuthorAttributes = AuthorAttributes().apply;

/**
 * Hash a string (document content) for easier comparison of state changes
 */
function hashString(str) {
    // if ((str + "").indexOf("\r") != -1) debugger
    return crypto
        .createHash("md5")
        .update(str, "binary")
        .digest("hex");
}

/**
 * Normalize document path to discard environment prefix
 */
function getDocPath(path) {
    if (path.indexOf(basePath) === 0) return path.substring(basePath.length + 1);
    return path;
}

var emitter = new events.EventEmitter();

/**
 * Document Store database wrapper utility to ease persistence/retrieval and update of entities such as:
 * Documents, Revisions, Environment, ChatMessages, Users
 */
var Store = (function() {
    /**
     * Create a `Document` from a template with path, contents
     * Also, create its Revision#0 record
     * @param {Object}   tmpl
     * @param {Function} callback
     */
    function newDocument(tmpl, callback) {
        var contents = tmpl.contents || "";
        var fsHash = tmpl.fsHash || hashString(contents);
        wrapSeq(
            Document.create({
                contents: new Buffer(contents),
                path: tmpl.path,
                fsHash: fsHash,
                authAttribs: contents.length ? JSON.stringify([contents.length, null]) : "[]",
                starRevNums: "[]",
                newLineChar: tmpl.newLineChar || DEFAULT_NL_CHAR_DOC,
                revNum: 0,
            }),
            function(err, doc) {
                if (err) return callback(err);
                wrapSeq(
                    Revision.create({
                        document_id: doc.id,
                        operation: new Buffer("[]"),
                        revNum: 0,
                    }),
                    function(err, rev) {
                        if (err) return callback(err);
                        doc.revisions = parseRevisions([rev]);
                        callback(null, parseDocument(doc));
                    }
                );
            }
        );
    }

    /**
     * Deletes a `Document` with all `Revisions` from DB by UNIQUE path
     * @param {String}   path the document path to query the database with
     * @param {Function} callback
     */
    function deleteDocument(path, callback) {
        wrapSeq(
            Document.find({
                where: {
                    path: path,
                },
            }),
            function(err, doc) {
                if (err) return callback(err);
                wrapSeq(
                    Document.destroy({
                        path: path,
                    }),
                    function(err) {
                        if (err) return callback(err);
                        wrapSeq(
                            Revision.destroy({
                                document_id: doc.id,
                            }),
                            function(err) {
                                if (err) return callback(err);
                            }
                        );
                    }
                );
            }
        );
    }

    function moveDocument(docId, newPath, callback) {
        wrapSeq(Document.find({where: {path: docId}}), function(err, doc) {
            if (err || !doc) return callback(err || new Error("No document found to rename!"));
            doc.path = newPath;
            wrapSeq(doc.save(), callback);
        });
    }

    function parseDocument(doc) {
        if (doc.authAttribs) doc.authAttribs = JSON.parse(doc.authAttribs);
        if (doc.starRevNums) doc.starRevNums = JSON.parse(doc.starRevNums);
        doc.contents = doc.contents && doc.contents.toString(); // because it can be a buffer
        return doc;
    }

    function parseDocumentCallback(callback) {
        return function(err, doc) {
            if (err || !doc) return callback(err);

            callback(null, parseDocument(doc));
        };
    }

    /**
     * Get a `Document` from the database given its path
     * @param {String}   path the document path to query the database with
     * @param [{String}] attributes - optional
     * @param {Function} callback
     * @param {Object} callback.err
     * @param {Object} callback.result   The result, or null if getDocument() failed (might even though err is null)
     */
    function getDocument(path, attributes, callback) {
        var query = {where: {path: getDocPath(path)}};
        if (!callback) {
            callback = attributes;
            attributes = undefined;
        } else {
            attributes.unshift("id");
            query.attributes = attributes; // ["id", other attributes]
        }

        return wrapSeq(Document.find(query), parseDocumentCallback(callback));
    }

    /**
     * Get the revisions of a certain document
     * @param {Document} doc
     * @param {Function} callback
     */
    function getRevisions(doc, callback) {
        wrapSeq(doc.getRevisions(), function(err, revisions) {
            if (err) return callback(err);
            callback(null, parseRevisions(revisions));
        });
    }

    /**
     * In-place parsing of revisions
     * @param [{Revision}] revisions
     */
    function parseRevisions(revisions) {
        revisions.forEach(function(rev) {
            // rev.operation can be a buffer and is always a stringified JSON array
            rev.operation = JSON.parse(rev.operation.toString());
        });
        revisions.sort(function(a, b) {
            return a.revNum - b.revNum;
        });
        return revisions;
    }

    /**
     * Save a document with changes to the database
     * @param {Function} callback
     */
    function saveDocument(doc, callback) {
        var authAttribs = doc.authAttribs;
        var starRevNums = doc.starRevNums;
        doc.authAttribs = JSON.stringify(authAttribs);
        doc.starRevNums = JSON.stringify(starRevNums);
        doc.contents = new Buffer(doc.contents);
        doc.updated_at = new Date();
        doc.lastUpdate = doc.updated_at.getTime();
        logger.info("Saving document to db with lastUpdate: " + doc.lastUpdate);

        return wrapSeq(doc.save(), function(err) {
            doc.authAttribs = authAttribs;
            doc.starRevNums = starRevNums;
            callback(err, doc);
        });
    }

    /**
     * Gets the latest environment state with the most important properties being: aurhorPool and colorPool
     * @param {Function} callback
     */
    function getEnvironmentState(callback) {
        // the table has only a single entry
        if (cachedWS) return callback(null, cachedWS);
        wrapSeq(Environment.find({where: {id: 1}}), function(err, ws) {
            if (err || !ws) return callback(err || new Error("No environment state found!"));
            ws.authorPoolParsed = parseJSONField(ws.authorPool);
            ws.colorPoolParsed = parseJSONField(ws.colorPool);
            cachedWS = ws;
            callback(null, ws);
        });
    }

    /**
     * Save the environment with changes to the database
     * @param {Environment} ws
     * @param {Function}  callback
     */
    function saveEnvironmentState(ws, callback) {
        var authorPool = ws.authorPoolParsed;
        var colorPool = ws.colorPoolParsed;
        ws.authorPool = JSON.stringify(authorPool);
        ws.colorPool = JSON.stringify(colorPool);
        return wrapSeq(ws.save(), function(err, savedWS) {
            if (err) {
                cachedWS = null;
                return callback(err);
            }
            savedWS.authorPoolParsed = authorPool;
            savedWS.colorPoolParsed = colorPool;
            cachedWS = savedWS;
            callback(null, savedWS);
        });
    }

    /**
     * Reset the workspace
     * @param {Function}  callback
     */
    function resetEnvironmentState(callback) {
        cachedWS = null;
        getEnvironmentState(callback);
    }

    /**
     * Save a document with changes to the database
     * @param {Function} callback
     */
    function getUsers(callback) {
        if (cachedUsers) return callback(null, cachedUsers);
        wrapSeq(User.all(), function(err, users) {
            cachedUsers = users;
            callback(err, users);
        });
    }

    /**
     * Add uer's chat message to the database
     * @param {String}   text
     * @param {String}   userId
     * @param {Function} callback
     */
    function saveChatMessage(text, user, callback) {
        wrapSeq(
            ChatMessage.create({
                text: text,
                userId: user.userId,
                name: user.name,
            }),
            callback
        );
    }

    /**
     * Get all chat message from the database by UserId
     * @param {String}   userId
     * @param {Function} callback
     */
    function getChatMessages(userId, callback) {
        wrapSeq(
            ChatMessage.findAll({
                where: {
                    userId: userId,
                },
            }),
            function(err, messages) {
                if (err) return callback(err);
                callback(null, messages);
            }
        );
    }

    /**
     * Get the most recent chat messages
     * @param {Number}   limit - optional
     * @param {Function} callback
     */
    function recentChatHistory(limit, callback) {
        limit = limit || 100;
        wrapSeq(
            ChatMessage.findAll({
                order: "timestamp DESC",
                limit: limit,
            }),
            function(err, history) {
                if (err) return callback(err);
                callback(null, history.reverse());
            }
        );
    }

    return {
        newDocument: newDocument,
        moveDocument: moveDocument,
        deleteDocument: deleteDocument,
        getDocument: getDocument,
        getRevisions: getRevisions,
        saveDocument: saveDocument,
        getEnvironmentState: getEnvironmentState,
        saveEnvironmentState: saveEnvironmentState,
        resetEnvironmentState: resetEnvironmentState,
        getUsers: getUsers,
        saveChatMessage: saveChatMessage,
        recentChatHistory: recentChatHistory,
        getChatMessages: getChatMessages,
    };
})();

// This object should have the following structure:
//
//     { <document id> : { <client id> : true } }
var documents = Object.create(null);

// This object should have the following structure:
//
//     { <document id> : { fs.FSWatcher } }
var watchers;

// This object should have the following structure:
//
//     { <client id> : <client> }
var clients;

var lastSaveStarts = Object.create(null);

// SQLite doesn't provide atomic instructions or locks
// So this variable expresses in-process locks
// Used to block concurrent edit updates while the document is being processed
//
//     { <key or document_id> : [{Function}] }
var locks = Object.create(null);
function lock(key, callback) {
    if (!locks[key]) {
        locks[key] = [];
        return callback();
    }

    var watchdog = setTimeout(function() {
        throw Error("Lock timeout"); // log & suicide
    }, 60000);
    return locks[key].push(function() {
        clearTimeout(watchdog);
        callback();
    });
}

function unlock(key) {
    var lock = locks[key];
    if (!lock || !lock.length) return delete locks[key];
    var next = lock.shift();
    next();
}

// Selected using colors.html
var featuredColors = [
    {r: 255, g: 146, b: 45},
    {r: 157, g: 47, b: 254},
    {r: 105, g: 215, b: 83},
    {r: 255, g: 105, b: 130},
    {r: 200, g: 109, b: 218},
    {r: 210, g: 230, b: 51},
    {r: 6, g: 134, b: 255},
    {r: 254, g: 13, b: 244},
    {r: 188, g: 255, b: 86},
    {r: 255, g: 212, b: 125},
    {r: 107, g: 4, b: 255},
    {r: 66, g: 248, b: 255},
];

// An algorithm to select bright random colors
function randomColor() {
    var a, b, c;
    do {
        a = Math.random();
        b = Math.random();
        c = Math.max(a, b);
    } while (c < 0.001);

    // scale them such that the larger number scales to 1.0f
    var scale = 1.0 / c;
    a *= scale;
    b *= scale;

    // Pick third value, ensure it's dark.
    c = Math.random() * 0.5;
    var rgb = new Array(3);

    var idx = Math.floor(Math.random() * 3) % 3;
    rgb[idx] = a;

    var rnd2 = Math.floor(Math.random() * 2) + 1;
    var idx2 = (rnd2 + idx) % 3;
    rgb[idx2] = b;

    var idx3 = 3 - (idx + idx2);
    rgb[idx3] = c;

    rgb = rgb.map(function(x) {
        return Math.floor(255 * x);
    });
    return {r: rgb[0], g: rgb[1], b: rgb[2]};
}

/**
 * Handle new collab connections (can be reconnects)
 * Sync user's info to the collab database and select a color and aurhor id for him/her if not previously set
 * Send USER_JOIN notifications to other connected members
 * Send handshake CONNECT message to the user with the needed environment info and chat history
 */
function handleConnect(userIds, client) {
    var userId = userIds.userId || -1;
    var clientId = userIds.clientId;

    function done(err) {
        if (!err) return;
        logger.error(err);
        client.send({
            type: "CONNECT",
            error: err,
        });
    }

    // Make sure to cache user's info
    syncUserInfo();

    function syncUserInfo() {
        var name = userIds.name;

        wrapSeq(User.find({where: {userId: userId}}), function(err, user) {
            if (err) return done("syncUserInfo " + String(err));

            if (!user) {
                return wrapSeq(
                    User.create({
                        userId: userId,
                        name: name,
                    }),
                    function(err, createdUser) {
                        if (err) return done("Failed creating user " + String(err));
                        cachedUsers && cachedUsers.push(createdUser);
                        augmentEnvironmentInfo();
                    }
                );
            }

            if (user.name === name) return augmentEnvironmentInfo();

            user.name = name;
            wrapSeq(user.save(), function(err, user) {
                if (err) return done("Failed updating user " + String(err));
                augmentEnvironmentInfo();
            });
        });
    }

    function augmentEnvironmentInfo() {
        Store.getEnvironmentState(function(err, ws) {
            if (err) return done("augmentEnvironmentInfo " + String(err));
            var authorPool = ws.authorPoolParsed;
            var colorPool = ws.colorPoolParsed;

            if (authorPool[userId] && colorPool[userId]) return doConnect(authorPool, colorPool);

            if (!authorPool[userId]) authorPool[userId] = Object.keys(authorPool).length + 1;
            if (!colorPool[userId])
                colorPool[userId] = featuredColors[authorPool[userId] - 1] || randomColor();
            Store.saveEnvironmentState(ws, function(err) {
                if (err) return done("augmentEnvironmentInfo " + String(err));
                doConnect(authorPool, colorPool);
            });
        });
    }

    function doConnect(authorPool, colorPool) {
        Store.getUsers(function(err, users) {
            if (err) return done("getUsers " + String(err));

            if (users.length > 1)
                logger.info(
                    "User",
                    userIds.userId,
                    "is connecting to an environment with",
                    users.length - 1,
                    "other environment members"
                );

            var onlineUsers = {};
            var idleUsers = {};
            for (var clId in clients) {
                var cl = clients[clId];
                var userId = cl.userIds.userId;
                if (!onlineUsers[userId]) onlineUsers[userId] = [];
                onlineUsers[userId].push(clId);
                var idleClinet = cl.state === "idle";
                if (typeof idleUsers[userId] === "undefined") idleUsers[userId] = idleClinet;
                // set through a USER_STATE message
                else idleUsers[userId] = idleUsers[userId] && idleClinet;
            }

            if (Object.keys(onlineUsers).length > 1)
                logger.info(
                    "User",
                    userIds.userId,
                    "is connecting Collab with",
                    Object.keys(clients).length - 1,
                    "other clients & online environment members",
                    onlineUsers
                );

            var usersMap = {};
            users.forEach(function(user) {
                var userId = user.userId;
                var onlineUserClients = onlineUsers[userId] || [];
                var onlineState;
                if (idleUsers[userId]) onlineState = "idle";
                else if (onlineUserClients.length) onlineState = "online";
                else onlineState = "offline";
                usersMap[userId] = {
                    name: user.name,
                    userId: user.userId,
                    clients: onlineUserClients,
                    online: onlineUserClients.length,
                    state: onlineState,
                    author: authorPool[userId],
                    color: colorPool[userId],
                };
            });

            broadcast(
                {
                    type: "USER_JOIN",
                    data: {
                        userId: userId,
                        clientId: clientId,
                        user: usersMap[userId],
                    },
                },
                client
            );

            Store.recentChatHistory(100, function(err, chatHistory) {
                if (err) logger.error("recentChatHistory", err);

                client.send({
                    type: "CONNECT",
                    data: {
                        myClientId: clientId,
                        myUserId: userId,
                        fs: userIds.fs,
                        authorPool: authorPool,
                        colorPool: colorPool,
                        users: usersMap,
                        chatHistory: chatHistory || [],
                    },
                });
            });
        });
    }
}

/**
 * Returns true if the users has read access to the filesystem
 */
function collabReadAccess(fs) {
    return /r/.test(fs);
}

/**
 * Returns true if the users has write access to the filesystem
 */
function collabWriteAccess(fs) {
    return /w/.test(fs);
}

/**
 * Apply a user's operation to a document
 * @param {Object}    userIds - user descriptor with: userId, name, fs, clientId
 * @param {String}    docId   - the document path
 * @param {Document}  doc     - the document to apply the operation on
 * @param {Operation} op      - the operation to applly
 * @param {Function}  callback
 */
function applyOperation(userIds, docId, doc, op, callback) {
    userIds = userIds || {userId: 0};
    var userId = userIds.userId;
    Store.getEnvironmentState(function(err, ws) {
        if (err) return callback(err);
        try {
            doc.contents = applyContents(op, doc.contents);
            applyAuthorAttributes(doc.authAttribs || [], op, ws.authorPoolParsed[userId]);

            wrapSeq(
                Revision.create({
                    operation: new Buffer(JSON.stringify(op)),
                    author: userId,
                    revNum: doc.revNum + 1,
                    document_id: doc.id,
                }),
                next
            );
        } catch (e) {
            return next(e);
        }
    });
    function next(err) {
        if (err) return callback(err);
        if (userId == 0) {
            detectCodeRevertError(op, doc.revNum, doc);
        }
        var contentsHash = hashString(doc.contents);
        doc.revNum++;
        logger.info(
            "applyOperation saveDocument User " +
                userId +
                " client " +
                userIds.clientId +
                " doc " +
                docId +
                " revNum " +
                doc.revNum +
                " fsHash " +
                doc.fsHash +
                " contentsHash " +
                contentsHash +
                " time: " +
                Date.now()
        );
        Store.saveDocument(doc, function(err) {
            if (err) return callback(err);

            logger.info(
                "applyOperation successfully saved User " +
                    userId +
                    " client " +
                    userIds.clientId +
                    " doc " +
                    docId +
                    " revNum " +
                    doc.revNum +
                    " fsHash " +
                    doc.fsHash +
                    " contentsHash " +
                    contentsHash +
                    " time: " +
                    Date.now()
            );
            var msg = {
                docId: docId,
                clientId: userIds.clientId,
                userId: userId,
                revNum: doc.revNum,
                op: op,
            };
            callback(null, msg);
        });
    }
}

function detectCodeRevertError(operation, lastRevisionNum, doc) {
    Store.getRevisions(doc, function(err, revisions) {
        if (err)
            return logger.error("Failed to get document revisions in detectCodeRevertError", err);

        var lastRevision = revisions[lastRevisionNum];
        if (!lastRevision || !lastRevision.operation) return;

        var lastOperation = lastRevision.operation;
        if (operation.length != lastOperation.length) return;

        if (!areOperationsMirrored(operation, lastOperation)) return;

        logger.warn(
            "ERROR: Detected code revert by system in ",
            doc.path,
            "revision " + (lastRevisionNum + 1) + ". Investigation needed."
        );
    });
}

// Check if all operations are the same except for insert/delete which is the opposite
function areOperationsMirrored(operation1, operation2) {
    if (!operation1.length || !operation2.length) return false;
    operation1 = removeNoopOperations(operation1);
    operation2 = removeNoopOperations(operation2);

    function areOpsMirrors(op1, op2) {
        if (!op1.length || !op2.length) return true;
        if (["i", "d"].indexOf(op1.charAt(0)) >= 0 && ["i", "d"].indexOf(op2.charAt(0)) >= 0) {
            if (op1.charAt(0) != op2.charAt(0) && op1.slice(1) == op2.slice(1)) {
                return true;
            }
        } else if (op1 == op2) {
            return true;
        }
    }

    for (var i = 0; i < operation1.length; i++) {
        if (areOpsMirrors(operation1[i], operation2[i])) continue;

        // Check if they are mirrored and order is just flipped
        if (
            operation2[i + 1] != null &&
            areOpsMirrors(operation1[i], operation2[i + 1]) &&
            areOpsMirrors(operation1[i + 1], operation2[i])
        ) {
            i++; // As we already compared this and the next
            continue;
        }

        return false;
    }

    return true;
}

function removeNoopOperations(ops) {
    var operations = ops.filter(function(op) {
        if (["d", "i", "r0"].indexOf(op) >= 0) {
            return false;
        }
        return true;
    });

    return operations;
}

/**
 * Handle user's EDIT_UPDATE for a document
 * @param {Object} userIds - user descriptor with: userId, name, fs, clientId
 * @param {Socket} client  - the connected collab client
 * @param {Object} data    - the EDIT_UPDATE message data with the document id, revision number and applied operation
 */
function handleEditUpdate(userIds, client, data) {
    var docId = data.docId;
    var userId = userIds.userId;
    var clientId = userIds.clientId;
    var newRev = data.revNum;
    var docL;

    logger.info(
        "handleEditUpdate User " +
            userId +
            " client " +
            clientId +
            " doc " +
            docId +
            " revision " +
            newRev
    );
    function done(err) {
        unlock(docId);
        if (err) {
            syncCommit(err);
        }
    }

    // the user's edit couldn't be commited, please try again
    function syncCommit(err) {
        logger.error(
            "encountered syncCommit error User " +
                userId +
                " client " +
                clientId +
                " doc " +
                docId +
                " revision " +
                newRev,
            err
        );
        client.send({
            type: "SYNC_COMMIT",
            data: {
                docId: docId,
                revNum: docL && docL.revNum,
                reason: err.message || err,
                code: err.code || "SYNC_E",
            },
        });
    }

    if (!documents[docId] || !documents[docId][clientId] || !client.openDocIds[docId])
        return done(
            "Trying to update a non-member document!",
            docId,
            clientId,
            documents[docId] && Object.keys(documents[docId]),
            Object.keys(client.openDocIds),
            Object.keys(documents),
            Object.keys(clients)
        );

    if (!collabWriteAccess(userIds.fs))
        return done(
            "User " +
                userIds.userId +
                " doesn't have write access to edit document " +
                docId +
                " - fs: " +
                userIds.fs
        );

    // Lock a document while updating - to stop any possible inconsistencies
    lock(docId, function() {
        Store.getDocument(docId, function(err, doc) {
            if (err || !doc) return done(err || "No Document to update! " + docId);

            docL = doc;

            if (doc.revNum !== newRev - 1) {
                // conflicting versions
                var err2 = new Error("Version log: " + docId + " " + doc.revNum + " " + newRev);
                err2.code = "VERSION_E";
                return done(err2);
            }

            // message.author for udno auth attributes
            applyOperation(userIds, docId, doc, data.op, function(err, msg) {
                if (err) {
                    var err2 = new Error("OT Error: " + String(err));
                    err2.code = "OT_E";
                    return done(err2);
                }

                msg.selection = data.selection;
                var contentsHash = hashString(doc.contents);
                logger.info(
                    "broadcasting EDIT_UPDATE User " +
                        userId +
                        " client " +
                        clientId +
                        " doc " +
                        docId +
                        " revision " +
                        newRev +
                        " fsHash " +
                        doc.fsHash +
                        " contentsHash " +
                        contentsHash
                );
                broadcast(
                    {
                        type: "EDIT_UPDATE",
                        data: msg,
                    },
                    client,
                    docId
                );

                delete msg.op;
                delete msg.selection;

                client.send({
                    type: "EDIT_UPDATE",
                    data: msg,
                });

                emitEventForAllCollaborators("afterEditUpdate", {
                    docId: docId,
                    path: getAbsolutePath(docId),
                    doc: doc,
                });
                done();
            });
        });
    });
}

/**
 * This function is used to propertly emit events for collab which can be caught by
 * code listening to master and slave collab emitter.
 *
 * It emits event for emitter from context and also broadcast special "COLLAB_EVENT"
 * which is handled by clients (the code in `collab_server` as well).
 * Client then passes this event to emitter they have in their context.
 *
 * This event can be used later by VFS extensions to be able to communicate with collab.
 *
 * For more details see https://i.amazon.com/AWS-Cloud9-7657
 */
function emitEventForAllCollaborators(eventName, data) {
    data.eventName = eventName;

    broadcast({
        type: "COLLAB_EVENT",
        data: data,
    });

    emitter.emit(eventName, data);
}

function handleResolveConflict(userInfo, client, data) {
    var docId = data.docId;
    logger.info("Handling resolve conflict with data: ", data, " doc is: ", documents[docId]);
    broadcast(
        {
            type: "RESOLVE_CONFLICT",
            data: data,
        },
        client,
        docId
    );
}

/**
 * Handle user's UPDATE_NL_CHAR for a document
 * @param {Object} userIds - user descriptor with: userId, name, fs, clientId
 * @param {Socket} client  - the connected collab client
 * @param {Object} data    - the UPDATE_NL_CHAR message data with the document id, newLineChar
 */
function handleUpdateNlChar(userInfo, client, data) {
    var docId = data.docId;
    var newLineChar = data.newLineChar || "";

    var nlCharLog;
    switch (newLineChar) {
        case "\n":
            nlCharLog = "\\n";
            break;
        case "\r\n":
            nlCharLog = "\\r\\n";
            break;
        default:
            nlCharLog = newLineChar.length + ":" + newLineChar;
            return missingInfo();
    }

    if (!docId) return missingInfo();

    function missingInfo() {
        logger.warn("updateNlChar missing info:", docId, nlCharLog);
    }

    function done(err) {
        unlock(docId);
        if (err) logger.error("updateNlChar failed:", err);
    }

    // Lock a document while updating - to stop any possible inconsistencies
    lock(docId, function() {
        Store.getDocument(docId, function(err, doc) {
            if (err || !doc)
                return done((err || "updateNlChar of a non-collab document!") + " : " + docId);
            if (doc.newLineChar == newLineChar) return done();
            doc.newLineChar = newLineChar;
            Store.saveDocument(doc, function(err) {
                if (err) return done(err);
                logger.debug("updateNlChar changed", newLineChar);

                broadcast(
                    {
                        type: "UPDATE_NL_CHAR",
                        data: {
                            docId: docId,
                            newLineChar: newLineChar,
                        },
                    },
                    client,
                    docId
                );
                done();
            });
        });
    });
}

/**
 * Handle user's CHAT_MESSAGE
 * @param {Object} user    - user descriptor with: userId, name, fs, clientId
 * @param {Socket} client  - the connected collab client
 * @param {Object} data    - the CHAT_MESSAGE data with the chat text
 */
function handleChatMessage(user, client, data) {
    var text = data.text;
    var userId = user.userId;
    var name = user.name;

    // Save the chat message and broadcast it
    Store.saveChatMessage(text, user, function(err, message) {
        if (err) return logger.error("saveChatMessage:", err);
        var msg = {
            type: "CHAT_MESSAGE",
            data: {
                id: message.id,
                userId: userId,
                name: name,
                timestamp: message.timestamp,
                text: text,
            },
        };

        broadcast(msg);
    });
}

/**
 * Handle Authorization change notification (AUTHORIZATION_CHANGED)
 * @param {Object} user - user descriptor with: userId, name, fs, clientId
 * @param {Socket} client  - the connected collab client
 */
function handleAuthorizationChanged(user, client) {
    // Broadcast notification of change
    broadcast({type: "AUTHORIZATION_CHANGED"}, client);
}

/**
 * Handle user's CURSOR_UPDATE messages
 * @param {Object} userIds - user descriptor with: userId, name, fs, clientId
 * @param {Socket} client  - the connected collab client
 * @param {Object} data    - the CURSOR_UPDATE data with the document id and the user selection
 */
function handleCursorUpdate(userIds, client, data) {
    var docId = data.docId;
    var clientId = userIds.clientId;

    if (!documents[docId] || !documents[docId][clientId] || !client.openDocIds[docId])
        return logger.warn(
            "Trying to select in a non-member document!",
            docId,
            clientId,
            documents[docId] && Object.keys(documents[docId]),
            Object.keys(client.openDocIds),
            Object.keys(documents),
            Object.keys(clients)
        );

    documents[docId][clientId].selection = data.selection;
    data.clientId = clientId;
    data.userId = userIds.userId;
    broadcast(
        {
            type: "CURSOR_UPDATE",
            data: data,
        },
        client,
        docId
    );
}

/**
 * Broadcast a message to all or a selected group of connected collab clients
 * @param {Object} message - the message to broadcast
 * @param {Socket} sender  - optional, when we want to exclude the sender from the group to send the message to
 * @param {String} docId   - the document id or path
 */
function broadcast(message, sender, docId) {
    var toClientIds = docId ? documents[docId] : clients;
    var audienceNum = 0;
    for (var clientId in toClientIds) {
        var client = clients[clientId];
        // Exclude sender if exists
        if (client === sender || !client) continue;
        client.send(message);
        audienceNum++;
    }

    if (audienceNum > 0) {
        logger.debug("Broadcast message sent: ", JSON.stringify(message));
    }
}

function getAbsolutePath(docId) {
    if (docId[0] === "~" && docId[1] === "/") return Path.join(getHomeDir(), docId.substring(1));
    else return Path.join(basePath, docId);
}

/**
 * Watch documents for other filesystem changes and sync them back to the collab documents
 * @param docId - the document id or path
 */
function initVfsWatcher(docId) {
    var absPath = getAbsolutePath(docId);

    function done(err) {
        if (err && err.code != "ENOENT") logger.error("WATCH ERR:", docId, err.code);
        unlock(docId);
    }

    // Check if a collab document sync is needed, apply it and save to the filesystem
    function doWatcherSync(stats, next) {
        var ctime = new Date(stats.ctime).getTime();
        var watcher = watchers[docId] || {};
        var timeDiff = ctime - watcher.ctime;
        logger.debug("WATCH CHANGE:", docId, "last ctime:", watcher.ctime, "new ctime:", ctime);
        if (watcher.ctime && timeDiff < 1) return;
        lock(docId, function() {
            logger.debug("WATCH SYNC:", docId, "time diff: ", timeDiff);
            watcher.ctime = ctime;
            Store.getDocument(docId, function(err, oldDoc) {
                if (err) return next(err);
                syncDocument(docId, oldDoc, null, false, function(err, doc2) {
                    if (err) return next(err);
                    if (doc2.syncedWithDisk) {
                        doSaveDocument(docId, doc2, -1, true, function(err, result) {
                            if (err) return next(err);
                            broadcast({type: "FILE_SAVED", data: result}, null, docId);
                            next();
                        });
                        delete doc2.syncedWithDisk;
                    }
                    next();
                });
            });
        });
    }

    localfsAPI.watch(absPath, {}, function(err, meta) {
        if (err) return logger.error("WATCH INIT ERR:", docId, err);

        var watcher = meta.watcher;
        watcher.on("change", function(event, filename, stat, files) {
            if (stat.vfsWrite)
                // ignore our own writes
                return;
            doWatcherSync(stat, done);
        });
        watcher.on("error", function(err) {
            logger.error("WATCH ERR:", docId, err && err.code);
        });
        watchers[docId] = watcher;
        watcher.ctime = Date.now();
        Fs.stat(absPath, function(err, stat) {
            if (err) return;
            watcher.ctime = new Date(stat.ctime).getTime();
        });
    });
}

/**
 * Handle user's JOIN_DOC messages - a user is joining a document to collaborate on
 * @param {Object} userIds - user descriptor with: userId, name, fs, clientId
 * @param {Socket} client  - the connected collab client
 * @param {Object} data    - the JOIN_DOC data with the document id
 */
function handleJoinDocument(userIds, client, data) {
    var docId = data.docId;
    var clientId = userIds.clientId;
    var userId = userIds.userId;

    logger.info("User", clientId, "trying to join document", docId);

    function done(err) {
        if (err) {
            logger.error("handleJoinDocument ERR:", err);
            client.send({
                type: "JOIN_DOC",
                data: {
                    clientId: clientId,
                    docId: docId,
                    err: err,
                },
            });
        }
        logger.info("User", clientId, "joined document", docId);
        unlock(docId);
    }

    lock(docId, function() {
        Store.getDocument(docId, function(err, doc) {
            if (err) return done("getDocument " + String(err));

            if (doc && documents[docId]) return fetchMetadataThenJoinDocument(doc);

            logger.info("Joining a closed document", docId, " - Syncing");
            syncDocument(docId, doc, client, false, function(err, doc2) {
                if (err) return done(err);
                fetchMetadataThenJoinDocument(doc2);
            });
        });
    });

    function fetchMetadataThenJoinDocument(doc) {
        localfsAPI.getMetadata(docId, {sandbox: basePath}, function(err, metadata) {
            if (err && err.code != "ENOENT") {
                var obfuscatedErr = err;
                logger.error("Warning: failed to fetch metadata!", obfuscatedErr);
            }

            var file = getAbsolutePath(docId);
            isVeryLargeFile(file, doc.contents, function(err, isLarge) {
                if (err) {
                    var obfuscatedErr = err;
                    logger.error("isVeryLargeFile failed:", obfuscatedErr);
                }
                if (!isLarge) return joinDocument(doc, String(metadata || ""));
                client.send({
                    type: "LARGE_DOC",
                    data: {
                        userId: userId,
                        clientId: clientId,
                        docId: docId,
                        response: true,
                    },
                });
            });
        });
    }

    function joinDocument(doc, metadata) {
        if (!documents[docId]) {
            documents[docId] = {};
            initVfsWatcher(docId);
            logger.info("User", clientId, "is joining document", docId);
        } else {
            logger.info(
                "User",
                clientId,
                "is joining a document",
                docId,
                "with",
                Object.keys(documents[docId]).length,
                "other document members"
            );
        }

        var docHash = hashString(doc.contents);

        var clientDoc = JSON.stringify({
            selections: documents[docId],
            authAttribs: doc.authAttribs,
            contents: doc.contents.toString(),
            metadata: metadata,
            fsHash: doc.fsHash,
            docHash: docHash,
            revNum: doc.revNum,
            newLineChar: doc.newLineChar,
            created_at: doc.created_at,
            updated_at: doc.updated_at,
            lastUpdate: doc.lastUpdate,
        });

        documents[docId][clientId] = userIds;
        client.openDocIds[docId] = true;

        logger.info(
            "User",
            clientId,
            "is opening",
            docId,
            "revNum",
            doc.revNum,
            "docHash",
            docHash,
            "fsHash",
            doc.fsHash
        );

        // Cut the document to pices and stream to the client
        var chunkSize = 10 * 1024; // 10 KB
        var contentsLen = clientDoc.length;
        var chunksLen = Math.ceil(contentsLen / chunkSize);
        for (var i = 0; i < contentsLen; i += chunkSize) {
            var chunk = clientDoc.slice(i, i + chunkSize);
            client.send({
                type: "JOIN_DOC",
                data: {
                    userId: userId,
                    clientId: clientId,
                    docId: docId,
                    reqId: data.reqId,
                    chunkNum: i / chunkSize + 1,
                    chunksLength: chunksLen,
                    chunk: chunk,
                },
            });
        }

        if (doc.hasPendingChanges) {
            logger.info(
                "Sending doc ",
                docId,
                " has pending changes to user ",
                userId,
                " client ",
                clientId
            );
            client.send({
                type: "DOC_HAS_PENDING_CHANGES",
                data: {
                    userId: userId,
                    clientId: clientId,
                    docId: docId,
                },
            });
            delete doc.hasPendingChanges;
        }

        if (doc.changedOnDisk) {
            logger.info(
                "Sending doc ",
                docId,
                " has changed on disk to user ",
                userId,
                " client ",
                clientId
            );
            client.send({
                type: "DOC_CHANGED_ON_DISK",
                data: {
                    userId: userId,
                    clientId: clientId,
                    docId: docId,
                },
            });
            delete doc.changedOnDisk;
        }

        broadcast(
            {
                type: "JOIN_DOC",
                data: {
                    docId: docId,
                    userId: userId,
                    clientId: clientId,
                },
            },
            client
        );

        done();
    }
}

/**
 * Normalize text line terminators for collab index-based calculations to seamlessly work
 * @param  {String} text
 * @return {String} normalized
 */
function normalizeTextLT(text) {
    return text.replace(/\r\n|\r/g, "\n");
}

// return "\n" or "\r\n" or null
function detectNewLineChar(text) {
    // Must be the strictly same as on the client
    // (and note that Ace doesn't have \r newLine mode)
    var match = text.match(/^.*?(\r\n|\n)/m);
    return match && match[1];
}

/**
 * Synchronize collab document state with the filesystem state (utilizing hashes)
 *
 * @param {String}   docId - the document id or path
 * @param {Document} doc   - the collab document
 * @param {Client} client   - the client requesting the sync
 * @param {Boolean} forceSync   - skip all the sanity checks, just sync from disk if the collab doc is different from disk
 * @param {Function} callback
 */
function syncDocument(docId, doc, client, forceSync, callback) {
    var file = getAbsolutePath(docId);

    isBinaryFile(file, function(err, isBinary) {
        if (err) return callback(new Error("SYNC: Binary check failed - ERR: " + String(err)));
        if (isBinary) return callback(new Error("SYNC: Binary file opened " + isBinary));

        isVeryLargeFile(file, null, function(err, isLarge) {
            if (err) return callback(err);

            if (!isLarge) return doSyncDocument();

            logger.warn("File is too large, ignoring: " + file);
            err = new Error("File is too large");
            err.code = "ELARGE";
            callback(err);
        });
    });

    function doSyncDocument() {
        Fs.readFile(file, "utf8", function(err, contents) {
            if (err) return callback(err);

            // "\n" or "\r\n" or null
            var newLineChar = detectNewLineChar(contents);
            var oldNewLineChar = (doc && doc.newLineChar) || DEFAULT_NL_CHAR_DOC;
            var normContents = normalizeTextLT(contents);

            var fsHash = hashString(normContents);

            if (doc && typeof doc.contents != "string" && doc.contents)
                doc.contents = doc.contents.toString(); // because it can be a buffer

            // HACK: fsHash from database is unreliable (https://github.com/c9/newclient/issues/3980)
            if (doc) doc.fsHash = hashString(doc.contents);

            if (!doc) {
                logger.info("SYNC: Creating document:", docId, fsHash);

                Store.newDocument(
                    {
                        path: docId,
                        contents: normContents,
                        fsHash: fsHash,
                        newLineChar: newLineChar,
                    },
                    callback
                );
            } else if (fsHash !== doc.fsHash && doc.contents != normContents) {
                // update database OT state
                logger.info(
                    "Doc",
                    docId,
                    " revnum: ",
                    doc.revNum,
                    "with hash:",
                    doc.fsHash,
                    "does not match file system hash",
                    fsHash
                );
                if (forceSync) return syncCollabDocumentWithDisk();

                // Check if the document was updated at the same time as this revision.
                // If it was then this doc has been saved as a revision before, no need to sync to it
                Fs.stat(file, function(err, stats) {
                    if (err) return callback(err);

                    var lastFileChange = stats.ctime.getTime();
                    var lastCollabChange = doc.lastUpdate;
                    var lastSaveStart = lastSaveStarts[docId];
                    logger.info(
                        "Doc",
                        docId,
                        "Last file change:",
                        lastFileChange,
                        " last collab change:",
                        lastCollabChange,
                        " last save start: ",
                        lastSaveStart
                    );

                    // Never sync if the last doc change is older than the last collab change
                    if (lastFileChange < lastCollabChange) {
                        if (!client) {
                            logger.info("Broadcasting document", docId, "has pending changes");
                            broadcast({
                                type: "DOC_HAS_PENDING_CHANGES",
                                data: {
                                    docId: docId,
                                },
                            });
                        } else {
                            doc.hasPendingChanges = true;
                        }
                        return callback(null, doc);
                    }

                    return documentContentsHaveChanged(lastCollabChange);
                });
            } else {
                checkNewLineChar();
                callback(null, doc);
            }

            function documentContentsHaveChanged(lastCollabChange) {
                var timeSinceLastCollabChange = Date.now() - lastCollabChange;
                if (wasLatestRevisionSaved(doc)) {
                    return syncCollabDocumentWithDisk();
                } else if (timeSinceLastCollabChange > UNSAVED_CHANGE_EXPIRY_TIME) {
                    logger.info(
                        "Doc ",
                        docId,
                        " last collab change was " +
                            timeSinceLastCollabChange / 1000 +
                            "s ago. Expiring change and syncing from disk"
                    );
                    return syncCollabDocumentWithDisk();
                }

                return informUserFileContentsHaveChanged();
            }

            function informUserFileContentsHaveChanged() {
                if (!client) {
                    logger.info("Broadcasting document", docId, "contents have changed");
                    broadcast({
                        type: "DOC_CHANGED_ON_DISK",
                        data: {
                            docId: docId,
                        },
                    });
                } else {
                    doc.changedOnDisk = true;
                }
                return callback(null, doc);
            }

            function syncCollabDocumentWithDisk() {
                var op = operations.operation(doc.contents, normContents);
                logger.info(
                    "SYNC: Syncing document from disk:",
                    docId,
                    op.length,
                    "fsHash",
                    fsHash,
                    "docHash",
                    doc.fsHash
                );
                // non-user sync operation
                doc.fsHash = fsHash; // applyOperation will save it for me

                doc.syncedWithDisk = true;
                doc.newLineChar = newLineChar || oldNewLineChar;
                applyOperation(null, docId, doc, op, function(err, msg) {
                    if (err)
                        return callback(
                            new Error(
                                "SYNC: Failed updating OT database document state! " + String(err)
                            )
                        );
                    msg.sync = true;
                    broadcast(
                        {
                            type: "EDIT_UPDATE",
                            data: msg,
                        },
                        null,
                        docId
                    );

                    checkNewLineChar();
                    callback(null, doc);
                });
            }

            function checkNewLineChar() {
                if (newLineChar && oldNewLineChar !== newLineChar) {
                    broadcast(
                        {
                            type: "UPDATE_NL_CHAR",
                            data: {
                                oldNewLineChar: oldNewLineChar,
                                newLineChar: newLineChar,
                            },
                        },
                        null,
                        docId
                    );
                    doc.newLineChar = newLineChar || oldNewLineChar;
                }
            }
        });
    }
}

/**
 * Handle user's GET_REVISIONS messages - retrive the revision history of the file
 *
 * @param {Object} userIds - user descriptor with: userId, name, fs, clientId
 * @param {Socket} client  - the connected collab client
 * @param {Object} data    - the JOIN_DOC data with the document id
 */
function handleGetRevisions(userIds, client, data) {
    var docId = data.docId;

    function done(err) {
        if (err) logger.error("handleGetRevisions ERR:", docId, err);
        unlock(docId);
    }

    lock(docId, function() {
        Store.getDocument(docId, function(err, doc) {
            if (err) return done("getDocument " + String(err));

            Store.getRevisions(doc, function(err, revisions) {
                if (err || !revisions)
                    return done("getRevisions " + (revisions || []).length + " " + String(err));

                var docRevisions = JSON.stringify({
                    revisions: revisions,
                    starRevNums: doc.starRevNums,
                    revNum: doc.revNum,
                });

                // Cut the revisions into pices and stream to the client
                var chunkSize = 10 * 1024; // 10 KB
                var contentsLen = docRevisions.length;
                var chunksLen = Math.ceil(contentsLen / chunkSize);
                for (var i = 0; i < contentsLen; i += chunkSize) {
                    var chunk = docRevisions.slice(i, i + chunkSize);
                    client.send({
                        type: "GET_REVISIONS",
                        data: {
                            userId: userIds.userId,
                            clientId: userIds.clientId,
                            docId: data.docId,
                            chunkNum: i / chunkSize + 1,
                            chunksLength: chunksLen,
                            chunk: chunk,
                        },
                    });
                }
                done();
            });
        });
    });
}

/**
 * Handle user's SAVE_FILE messages - save collab documents
 * @param {Object} userIds - user descriptor with: userId, name, fs, clientId
 * @param {Socket} client  - the connected collab client
 * @param {Object} data    - the SAVE_FILE data with the document id and wether to sielently save (with auto-save enabled) or star the save
 */
function handleSaveFile(userIds, client, data) {
    var st = Date.now();
    var docId = data.docId;
    var postProcessor = data.postProcessor;
    var userId = userIds.userId;

    lastSaveStarts[docId] = Date.now();

    function done(err, result) {
        unlock(docId);
        logger.info("File unlocked, docId: " + docId);
        if (err) {
            client.send({
                type: "FILE_SAVED",
                data: {
                    docId: docId,
                    err: err,
                },
            });

            logger.error("Failed to save file; ", err);

            return;
        }

        broadcast({type: "FILE_SAVED", data: result}, null, docId);
    }

    logger.info("Saving file", docId);
    client.send({type: "FILE_LOCKING", data: {docId: docId}});

    lock(docId, function() {
        logger.info("File " + docId + " locked");
        client.send({type: "FILE_LOCKED", data: {docId: docId}});
        Store.getDocument(docId, ["contents", "revNum", "starRevNums", "newLineChar"], function(
            err,
            doc
        ) {
            if (err || !doc) return done((err || "Writing a non-collab document!") + " : " + docId);

            if (watchers[docId]) watchers[docId].ctime = Date.now();

            client.send({type: "FILE_RETRIEVED", data: {docId: docId}});

            var absPath = getAbsolutePath(docId);
            var fileContents = doc.contents.replace(/\n/g, doc.newLineChar || DEFAULT_NL_CHAR_FILE);

            mkfileWriteFile(fileContents, writeFileCallback);

            function mkfileWriteFile(contents, callback) {
                var options = {bufferWrite: true};
                var stream = (options.stream = new Stream());
                stream.readable = true;
                localfsAPI.mkfile(absPath, options, callback);
                stream.emit("data", contents);
                stream.emit("end");
            }

            /*
            function regularWriteFile() {
                Fs.writeFile(absPath, doc.contents, "utf8", writeFileCallback);
            }
            */

            function writeFileCallback(err) {
                if (err) {
                    // Do not obfuscate docId here as this error is shown to the customer in the browser
                    return done("Failed saving file! : " + docId + " ERR: " + String(err));
                }

                logger.info("Data for file " + docId + " has been written successfully");

                client.send({type: "DATA_WRITTEN", data: {docId: docId}});
                doSaveDocument(docId, doc, userId, !data.silent, function(err, result) {
                    logger.info(
                        "Saving took",
                        Date.now() - st,
                        "ms - time is now: " + Date.now() + " file:",
                        docId,
                        !err
                    );
                    if (err) {
                        client.send({
                            type: "POST_PROCESSOR_ERROR",
                            data: {
                                code: err.code,
                                stderr: err.stderr,
                                docId: docId,
                            },
                        });
                        return done(err);
                    }

                    if (postProcessor) {
                        return execPostProcessor(
                            absPath,
                            docId,
                            doc,
                            fileContents,
                            client,
                            postProcessor,
                            function(err) {
                                done(err, result);
                            }
                        );
                    }

                    done(null, result);
                });
            }
        });
    });
}

function execPostProcessor(absPath, docId, doc, fileContents, client, postProcessor, callback) {
    localfsAPI.writeToWatchedFile(absPath, function(afterWrite) {
        localfsAPI.execFile(
            postProcessor.command,
            {
                args: postProcessor.args.map(function(a) {
                    return a.replace(/\$file/g, docId);
                }),
                cwd: basePath,
            },
            function(err, result) {
                if (err) {
                    client.send({
                        type: "POST_PROCESSOR_ERROR",
                        data: {
                            code: err.code,
                            stderr: err.stderr,
                            docId: docId,
                        },
                    });
                }

                syncDocument(docId, doc, null, true, function() {
                    afterWrite(callback);
                });
            }
        );
    });
}

/**
 * Apply the save to the collab document, update the hash and optionally add a star revision
 * @param {String}   docId     - the document id or path
 * @param {Document} doc       - the collab document
 * @param {String}  userId     - the user id
 * @param {Boolean} star       - add a star to the document if not triggered by auto-save
 * @param {Function} callback
 */
function doSaveDocument(docId, doc, userId, star, callback) {
    if (star && doc.starRevNums.indexOf(doc.revNum) === -1) doc.starRevNums.push(doc.revNum);

    var fsHash = (doc.fsHash = hashString(doc.contents));
    Store.saveDocument(doc, function(err) {
        if (err) return callback(err);
        logger.info(
            "User",
            userId,
            "saved document",
            docId,
            "revision",
            doc.revNum,
            "hash",
            fsHash
        );
        callback(null, {
            userId: userId,
            docId: docId,
            star: star,
            revNum: doc.revNum,
            fsHash: fsHash,
        });
    });
}

/**
 * Was the latest document revision saved to disk or is it just in the collabdb
 * @param {Document} doc
 */
function wasLatestRevisionSaved(doc) {
    return doc.starRevNums && doc.starRevNums.indexOf(doc.revNum) >= 0;
}

/**
 * Handle user's LEAVE_DOC messages - client closing a collab document
 * @param {Object} userIds - user descriptor with: userId, name, fs, clientId
 * @param {Socket} client  - the connected collab client
 * @param {Object} data    - the LEAVE_DOC data with the document id
 */
function handleLeaveDocument(userIds, client, data) {
    var docId = data.docId;
    var userId = userIds.userId;
    var clientId = userIds.clientId;
    var userDisconnected = data.disconnected;
    if (!documents[docId] || !documents[docId][clientId] || !client.openDocIds[docId])
        return logger.warn(
            "Trying to leave a non-member document!",
            docId,
            clientId,
            documents[docId] && Object.keys(documents[docId]),
            Object.keys(client.openDocIds),
            Object.keys(documents),
            Object.keys(clients)
        );
    delete client.openDocIds[docId];
    logger.info("[vfs-collab]", clientId, "is leaving document", docId);
    delete documents[docId][clientId];
    if (!Object.keys(documents[docId]).length) {
        logger.info("Closing document", docId);
        if (!userDisconnected) {
            // If the user closed this on purpose and it's the last user
            // Resync this document with what's on disk to remove unsaved collab changes
            logger.info("Last user closed document ", docId, " resyncing it from disk");
            Store.getDocument(docId, function(err, doc) {
                if (err)
                    return logger.error(
                        "Failed to get doc",
                        docId,
                        " from the store. Error is: ",
                        err
                    );
                syncDocument(docId, doc, null, true, function(err) {
                    if (err)
                        return logger.error("Failed to sync", docId, "with disk. Error is: ", err);
                    logger.info("Successfully synced document", docId, " with disk.");
                });
            });
        }
        closeDocument(docId);
    }

    broadcast(
        {
            type: "LEAVE_DOC",
            data: {
                docId: docId,
                userId: userId,
                clientId: clientId,
            },
        },
        client
    );
}

/**
 * Handle user's LARGE_DOC messages - document has grown too large for collab
 *
 * @param {Object} userIds - user descriptor with: userId, name, fs, clientId
 * @param {Socket} client  - the connected collab client
 * @param {Object} data    - the LEAVE_DOC data with the document id
 */
function handleLargeDocument(userIds, client, data) {
    var docId = data.docId;
    var userId = userIds.userId;
    var clientId = userIds.clientId;
    logger.debug("docId:", docId);
    delete documents[docId][clientId];
    if (!Object.keys(documents[docId]).length) {
        logger.info("File has grown too large, ignoring: " + docId);
        closeDocument(docId);
    }

    broadcast(
        {
            type: "LARGE_DOC",
            data: {
                docId: docId,
                userId: userId,
                clientId: clientId,
            },
        },
        client
    );
}

/**
 * Handle user's USER_STATE messages - update connected clients with user state
 * @param {Object} userIds - user descriptor with: userId, name, fs, clientId
 * @param {Socket} client  - the connected collab client
 * @param {Object} data    - the JOIN_DOC data with the document id
 */
function handleUserState(userIds, client, data) {
    var userId = userIds.userId;
    var clientId = userIds.clientId;
    logger.info("[vfs-collab]", clientId, "is switching to", data.state);
    clients[clientId].state = data.state;
    var isUserIdle = Object.keys(clients)
        .map(function(cliId) {
            return clients[cliId];
        })
        .filter(function(cl) {
            return cl.userIds.userId === userId;
        })
        .reduce(function(isIdle, cl) {
            return isIdle && cl.state === "idle";
        }, true);

    broadcast(
        {
            type: "USER_STATE",
            data: {
                state: isUserIdle ? "idle" : "online",
                userId: userId,
                clientId: clientId,
            },
        },
        client
    );
}

/**
 * Clears specific chat messages or complete chat history
 *
 * @param {Object} userIds - user descriptor with: userId, name, fs, clientId
 * @param {Socket} client  - the connected collab client
 * @param {Object} data    - either id: $id of the message to be deleted or clear: true to clear all of the chat history
 */
function handleClearChat(userIds, client, data) {
    logger.info("Clear chat history: ", data.id, data.clear, userIds.fs);

    if (!collabWriteAccess(userIds.fs))
        return logger.warn("clearChat: User don't have write access!");

    var stmt;
    if (data.clear) stmt = ChatMessage.destroy({}, {truncate: true});
    else if (data.id) stmt = ChatMessage.destroy({id: data.id});
    else return logger.warn("clearChat: Invalid message", data);

    wrapSeq(stmt, function(err) {
        if (err) {
            logger.error("Chat clear error:", err);
            return;
        }
        broadcast({
            type: "CLEAR_CHAT",
            data: data,
        });
    });
}

/**
 * Clears specific chat messages or complete chat history
 *
 * @param {Object} userIds - user descriptor with: userId, name, fs, clientId
 * @param {Socket} client  - the connected collab client
 * @param {Object} data    - either id: $id of the message to be deleted or clear: true to clear all of the chat history
 */
function broadcastUserMessage(userIds, client, data) {
    logger.info("Clear chat history: ", data.id, data.clear, userIds.fs);

    broadcast(
        {
            type: "MESSAGE",
            data: data,
        },
        client
    );
}

function isPathAllowed(userIds, docId) {
    // only accept normalized unix paths without /../ or /./ or ../
    if (/(\/|^)[.]{1,2}(\/|$)|\\/.test(docId)) return false;
    // do not allow redonly users to open ~
    if (userIds.fs == "r" && docId[0] === "~" && docId[1] === "/") return false;
    return true;
}

/**
 * Handle any user message by routing to its proper handler
 *
 * @param {Object} userIds - user descriptor with: userId, name, fs, clientId
 * @param {Socket} client  - the connected collab client
 * @param {Object} data    - the SAVE_FILE data with the document id and wether to sielently save (with auto-save enabled) or star the save
 */
function handleUserMessage(userIds, client, message) {
    var data = message.data || {};
    var docId = data.docId || "";
    if (docId[0] === "/") docId = docId.slice(1);

    if (!isPathAllowed(userIds, docId)) {
        return client.send({
            type: message.type,
            data: {
                clientId: userIds.clientId,
                docId: docId,
                err: {message: "Not allowed."},
            },
        });
    }
    data.docId = docId;
    switch (message.type) {
        case "JOIN_DOC":
            handleJoinDocument(userIds, client, data);
            break;
        case "GET_REVISIONS":
            handleGetRevisions(userIds, client, data);
            break;
        case "LEAVE_DOC":
            handleLeaveDocument(userIds, client, data);
            break;
        case "LARGE_DOC":
            handleLargeDocument(userIds, client, data);
            break;
        case "EDIT_UPDATE":
            handleEditUpdate(userIds, client, data);
            break;
        case "RESOLVE_CONFLICT":
            handleResolveConflict(userIds, client, data);
            break;
        case "UPDATE_NL_CHAR":
            handleUpdateNlChar(userIds, client, data);
            break;
        case "CURSOR_UPDATE":
            handleCursorUpdate(userIds, client, data);
            break;
        case "SAVE_FILE":
            logger.info("SAVE_FILE event received for docId: ", data.docId);
            handleSaveFile(userIds, client, data);
            break;
        case "CHAT_MESSAGE":
            handleChatMessage(userIds, client, data);
            break;
        case "USER_STATE":
            handleUserState(userIds, client, data);
            break;
        case "CLEAR_CHAT":
            handleClearChat(userIds, client, data);
            break;
        case "PING":
            client.send({type: "PING"});
            break;
        case "MESSAGE":
            broadcastUserMessage(userIds, client, data);
            break;
        case "AUTHORIZATION_CHANGED":
            handleAuthorizationChanged(userIds, client);
            break;
        case "GENERIC_BROADCAST":
            broadcast({type: message.type, data: data});
            break;
        default:
            throw new Error("Unknown message message type: " + message.type);
    }
}

/**
 * @param {Object} userIds - user descriptor with: userId, name, fs, clientId
 * @param {Socket} client  - the just-connected collab client
 */
function onConnect(userIds, client) {
    var userId = userIds.userId;
    var clientId = userIds.clientId;

    logger.info("CONNECTED UserID: " + userId + " & ClientId: " + clientId);

    client.on("message", function(message) {
        logger.debug("Message from userId:", userId, "message:" + message);
        try {
            message = JSON.parse(message);
        } catch (e) {
            return logger.error("Can't parse client data!", message, e);
        }
        try {
            handleUserMessage(userIds, client, message);
        } catch (e) {
            return logger.error("Can't handle user message", message, e);
        }
    });

    handleConnect(userIds, client);

    client.on("disconnect", function() {
        logger.info("Client disconnect, UserID: " + userId + " & ClientId: " + clientId);
        for (var docId in client.openDocIds)
            handleLeaveDocument(userIds, client, {docId: docId, disconnected: true});
        broadcast(
            {
                type: "USER_LEAVE",
                data: {
                    userId: userId,
                    clientId: clientId,
                },
            },
            client
        );
        logger.info("DISCONNECTED a socket with userId " + userId);
    });
}

var compressTimers = {};

/**
 * Close a document because it's no more open for collaboration, close the watcher and schedule a compression
 * @param {String} docId   - the document id or path
 */
function closeDocument(docId) {
    delete documents[docId];

    if (compressTimers[docId]) clearTimeout(compressTimers[docId]);
    compressTimers[docId] = setTimeout(function() {
        delete compressTimers[docId];
        compressDocument(docId, {
            MAX_REVISION_NUM: 256,
            COMPRESSED_REV_NUM: 128,
        });
    }, 100000);

    if (watchers[docId]) {
        watchers[docId].close();
        delete watchers[docId];
    }
}

/**
 * Pack documents' revisions if they go beyond a certain threshould: options.MAX_REVISION_NUM
 * to put it back to a reasonable number of revisions: options.COMPRESSED_REV_NUM
 *
 * It applies multiple heuristic algorithms to combine revisions trying not to lose any authorship information
 *
 * @param {String}   docId   - the document id or path
 * @param {Object}   options - compression configuration parameters
 * @param {Function} callback
 */
function compressDocument(docId, options, callback) {
    if (documents[docId]) return;

    var ALREADY_COMPRESSED = "ALREADY_COMPRESSED";
    var MAX_REVISION_NUM = options.MAX_REVISION_NUM;
    var COMPRESSED_REV_NUM = options.COMPRESSED_REV_NUM;

    var doc, revisions;
    var newRevisions, newStarRevNums;
    var starsHash, rev0Contents, lastRevTime, docTimeDiff, optimalRevTimeDiff;

    // compaction modes
    var mergeDifferentAuthors = false;
    var isAggressive = false;

    var secondTime = 1000;
    var minuteTime = secondTime * 60;
    var hourTime = minuteTime * 60;
    var dayTime = hourTime * 24;
    var fourDaysTime = dayTime << 2;

    function done(err) {
        unlock(docId);
        if (err === ALREADY_COMPRESSED) err = undefined;
        if (err) logger.error("ERROR Closing Document", docId, err);
        callback && callback(err);
    }

    function cloneRevision(rev, revNum) {
        return {
            document_id: rev.document_id,
            operation: rev.operation.slice(),
            author: rev.author,
            revNum: revNum,
            created_at: rev.created_at,
            updated_at: rev.updated_at,
        };
    }

    function shouldMergeTimeDiff(rev, lastRev) {
        if (lastRev.author != rev.author) {
            if (mergeDifferentAuthors) lastRev.author = "0";
            else return false;
        }

        var latestRevDiff = lastRevTime - rev.created_at;
        var prevRevDiff = rev.created_at - lastRev.created_at;

        if (isAggressive) return prevRevDiff < optimalRevTimeDiff << 1;

        if (latestRevDiff < hourTime)
            // previous revision is < 8-seconds away (co-editing)
            return prevRevDiff < secondTime << 3;
        else if (latestRevDiff < dayTime)
            // previous revision is < 4-minutes away
            return prevRevDiff < minuteTime << 2;
        else if (latestRevDiff < fourDaysTime)
            // previous revision is < 1-hour away
            return prevRevDiff < hourTime;
        else return prevRevDiff < optimalRevTimeDiff;
    }

    lock(docId, function() {
        async.series(
            [
                function(next) {
                    Store.getDocument(docId, function(err, docL) {
                        if (err || !docL) return next(err || "No document to close!");
                        doc = docL;
                        next();
                    });
                },
                function(next) {
                    Store.getRevisions(doc, function(err, revisionsL) {
                        if (err || !revisionsL) return next(err || "No document revisions found!");
                        if (revisionsL.length < MAX_REVISION_NUM) return next(ALREADY_COMPRESSED);
                        revisions = revisionsL;
                        next();
                    });
                },
                function prepare(next) {
                    // compress to the latest N/2 saves only
                    var newStars = doc.starRevNums.slice(-COMPRESSED_REV_NUM);

                    starsHash = {};
                    var i;
                    for (i = 0; i < newStars.length; i++) starsHash[newStars[i]] = true;

                    rev0Contents = doc.contents;
                    for (i = revisions.length - 1; i > 0; i--) {
                        var op = operations.inverse(revisions[i].operation);
                        revisions[i].contents = rev0Contents;
                        rev0Contents = applyContents(op, rev0Contents);
                    }

                    lastRevTime = revisions[revisions.length - 1].created_at;
                    docTimeDiff = lastRevTime - revisions[0].created_at;
                    optimalRevTimeDiff = docTimeDiff / COMPRESSED_REV_NUM;

                    next();
                },
                function compressDoc(next) {
                    var shouldCompress = revisions.length - COMPRESSED_REV_NUM;

                    logger.debug(
                        "Compress document trial",
                        docId,
                        shouldCompress,
                        mergeDifferentAuthors,
                        isAggressive
                    );

                    newRevisions = [cloneRevision(revisions[0], 0)];
                    newStarRevNums = [];

                    var lastRev = {author: -9};
                    var prevContents, prevLastContents;
                    var lastContents = rev0Contents;
                    var i, rev;
                    for (i = 1; i < revisions.length && shouldCompress; i++) {
                        rev = revisions[i];
                        prevLastContents = lastContents;
                        lastContents = applyContents(rev.operation, lastContents);
                        // Check if can merge revisions and clear lastRev's author if different & can merge different authors
                        // TODO: remove the side-effect on parameters the function do
                        if (shouldMergeTimeDiff(rev, lastRev)) {
                            var compressedOp = operations.operation(prevContents, lastContents);
                            lastRev.operation = compressedOp;
                            shouldCompress--;
                        } else {
                            lastRev = cloneRevision(rev, newRevisions.length);
                            newRevisions.push(lastRev);
                            prevContents = prevLastContents;
                        }
                        if (starsHash[i] && !lastRev.isStar) {
                            newStarRevNums.push(lastRev.revNum);
                            lastRev.isStar = true;
                        }
                    }
                    if (!shouldCompress) {
                        while (i < revisions.length) {
                            newRevisions.push(cloneRevision(revisions[i++], newRevisions.length));
                        }
                    } else if (!mergeDifferentAuthors) {
                        logger.warn(
                            "Merge single-author failed to compact the document enough",
                            revisions.length,
                            newRevisions.length
                        );
                        mergeDifferentAuthors = true;
                        return compressDoc(next);
                    } else if (!isAggressive) {
                        logger.warn(
                            "Merge multi-author failed to compact the document enough",
                            revisions.length,
                            newRevisions.length
                        );
                        isAggressive = true;
                        return compressDoc(next);
                    } else if (newRevisions.length >= MAX_REVISION_NUM) {
                        logger.warn(
                            "All compression modes failed to compact the document enough",
                            revisions.length,
                            newRevisions.length
                        );
                    }

                    logger.warn(
                        "Compressed document:",
                        revisions.length,
                        newRevisions.length,
                        "Different Authors:",
                        mergeDifferentAuthors,
                        "isAggressive:",
                        isAggressive
                    );
                    next();
                },
                function(next) {
                    wrapSeq(Revision.destroy({document_id: doc.id}), next);
                },
                function(next) {
                    doc.starRevNums = newStarRevNums;
                    doc.revNum = newRevisions.length - 1;
                    Store.saveDocument(doc, next);
                },
                function(next) {
                    newRevisions.forEach(function(newRev) {
                        delete newRev.isStar;
                        newRev.operation = JSON.stringify(newRev.operation);
                    });
                    wrapSeq(Revision.bulkCreate(newRevisions), next);
                },
            ],
            done
        );
    });
}

/**
 * Returns transform operation needed to be applied to transform document from `revNum` to latest revision.
 * As a second return value, returns the document at the passed revision number.
 * as a third return value, returns the revision number of the latest document found in the store.
 *
 * @param {String} Document ID (path)
 * @param {Number} revisionNumber Document revision number from where we need to transform
 */
function getDiffToLatestRevision(docId, fromRevision, callback) {
    var doc;
    var revisions;
    var diff;
    var revisionContents;

    function getDocument(next) {
        Store.getDocument(docId, function(err, result) {
            if (err || !result) return next(err);

            doc = result;
            next();
        });
    }

    function getRevisions(next) {
        Store.getRevisions(doc, function(err, result) {
            if (err || !result) return next(err);

            revisions = result;
            next();
        });
    }

    function getDiff(next) {
        revisionContents = doc.contents;
        for (var i = revisions.length - 1; i > 0; i--) {
            if (revisions[i].revNum == fromRevision) {
                break;
            }
            var op = operations.inverse(revisions[i].operation);
            revisions[i].contents = revisionContents;
            revisionContents = applyContents(op, revisionContents);
        }

        diff = operations.operation(revisionContents, doc.contents);
        next();
    }

    lock(docId, function() {
        async.series([getDocument, getRevisions, getDiff], function(err) {
            unlock(docId);
            var oldDoc = {
                contents: revisionContents,
                newLineChar: doc.newLineChar,
                revNum: fromRevision,
            };
            callback(err, diff, oldDoc, doc.revNum);
        });
    });
}

// ********* VFS Stream, net.Socket Collab Communication Infrastructure ************ //

/**
 * Create the collab socket net.Server
 * The net.Server is file-socket to allow multiple collab-enabled environments on SSH environments
 */
function createServer() {
    var server = net.createServer(function(client) {
        // logger.debug("Client connected");
        var userIds;
        var isClosed = false;

        client.send = function(msg) {
            if (isClosed) return;
            msg.command = msg.command || "vfs-collab";
            var strMsg = JSON.stringify(msg);
            client.write(strMsg + "\0");
        };

        client.on("data", function handShake(data) {
            client.removeListener("data", handShake);
            client.on("data", onData);

            userIds = JSON.parse(data);
            if (!collabReadAccess(userIds.fs))
                return logger.info(
                    "Client don't have read access to environment! - " +
                        "Note that visitors of private environments can't use collab features"
                );

            client.userIds = userIds;
            client.openDocIds = Object.create(null);
            clients[userIds.clientId] = client;
            logger.info("Server handshake initiated for clientId:", userIds.clientId);

            // handshaking the client
            client.write(data.toString());

            if (server.collabInited) onConnect(userIds, client);
            else
                server.once("collabInited", function() {
                    onConnect(userIds, client);
                });
        });

        var buff = [];

        function onData(data) {
            data = data.toString();
            var idx;
            while (true) {
                idx = data.indexOf("\0");
                if (idx === -1) return data && buff.push(data);
                buff.push(data.substring(0, idx));
                var clientMsg = buff.join("");
                data = data.substring(idx + 1);
                buff = [];
                client.emit("message", clientMsg);
            }
        }

        client.on("close", onClose);
        client.on("end", onClose);

        function onClose() {
            if (isClosed) return;
            isClosed = true;
            delete clients[userIds.clientId];
            client.emit("disconnect");
            logger.info("Client disconnected. clientId:", userIds.clientId);
        }

        client.on("error", function(err) {
            onClose();
            logger.error("CLIENT SOCKET ERROR", err);
            client.destroy();
        });
    });
    return server;
}

function initSocket(userIds, callback) {
    var projectWD = getProjectWD();
    var server;

    // file sockets can have multiple servers open on the same path
    // So, we connect first
    var sockPath =
        process.platform == "win32"
            ? "\\\\.\\pipe\\" + projectWD + "\\collab.sock"
            : Path.join(projectWD, "collab.sock");
    clientConnect();

    function startServer() {
        server = createServer();
        logger.debug(
            "PID:",
            PID,
            "Socket:",
            sockPath,
            "ClinetId:",
            userIds.clientId,
            " & UserId:",
            userIds.userId
        );

        async.series(
            [
                function(next) {
                    // Create the directoty ~/.c9 if not existing
                    Fs.mkdir(Path.dirname(projectWD), function(err) {
                        if (err && err.code !== "EEXIST") return next(err);
                        next();
                    });
                },
                function(next) {
                    // Create the directoty ~/.c9/$pid if not existing
                    Fs.mkdir(projectWD, function(err) {
                        if (err && err.code !== "EEXIST") return next(err);
                        next();
                    });
                },
                function(next) {
                    // Remove the stale socket, if existing at ~/.c9/$pid/collab.sock
                    Fs.unlink(sockPath, function(err) {
                        if (err && err.code !== "ENOENT") return next(err);
                        next();
                    });
                },
            ],
            function(err) {
                if (err) return callback(err);

                function closeServerThenCallback(err) {
                    try {
                        logger.error("Shuting down a faulty collab server - reason: ", err);
                        server.close();
                    } catch (e) {
                        logger.error("Can't shutdown faulty collab server", e);
                    }
                    callback(err);
                }

                server.listen(sockPath, function() {
                    isMaster = true;
                    server.collabInited = false;

                    // init server state
                    documents = Object.create(null);
                    watchers = Object.create(null);
                    clients = Object.create(null);

                    // Check server installation, init the server and then connect the client to the inited collab server
                    installServer(function(err) {
                        if (err) return closeServerThenCallback(err);

                        initDB(false, function(err, options) {
                            if (err) return closeServerThenCallback(err);

                            server.collabInited = true;
                            clientConnect();
                            server.emit("collabInited");
                        });
                    });

                    server.on("close", function() {
                        logger.info("Server closed");
                        // Should handover to another server (if exists)
                        // e.g. Elect the first client as the new master.
                    });
                });

                server.on("error", function(err) {
                    // if another connection/thread was able to listen as collab-server, let's just connect to it
                    if (err.code === "EADDRINUSE") return clientConnect();
                    else logger.error("Server error", err);
                });
            }
        );
    }

    // Connect to a collab client
    function clientConnect() {
        var stream = new Stream();
        stream.readable = true;

        var client = net.connect(sockPath, function() {
            client.setTimeout(0);
            client.setNoDelay(true);
            client.setKeepAlive(true);

            client.userIds = userIds;
            client.clientStream = stream;

            client.on("data", function handShake(data) {
                client.removeListener("data", handShake);
                client.on("data", onData);
            });

            var buff = [];

            /**
             * This function is used to process message that came from master to slave.
             * If the message is local (should be processed in slave and not sent to client), it processes message and returns true.
             * Otherwise it does nothing and returns false.
             */
            function processLocalMessages(streamData) {
                try {
                    var message = JSON.parse(streamData);
                } catch (e) {
                    logger.error("Can't parse data from collab master!", streamData, e);
                    return false;
                }
                if (message && message.type === "COLLAB_EVENT") {
                    var eventData = message.data;
                    eventData.docId = eventData.docId || "";
                    if (eventData.docId[0] === "/") eventData.docId = eventData.docId.slice(1);
                    emitter.emit(eventData.eventName, eventData);
                    return true;
                }

                return false;
            }

            function onData(data) {
                data = data.toString();
                var idx;
                while (true) {
                    idx = data.indexOf("\0");
                    if (idx === -1) return buff.push(data);
                    buff.push(data.substring(0, idx));
                    var streamData = buff.join("");
                    data = data.substring(idx + 1);
                    buff = [];

                    // Try to process local message
                    var processed = processLocalMessages(streamData);
                    // If it's not local message and it's not been processed, send data to client stream.
                    if (!processed) stream.emit("data", streamData);
                }
            }

            client.on("close", function() {
                stream.emit("end");
            });

            client.write(JSON.stringify(userIds), "utf8", function() {
                callback(null, client, isMaster && server);
            });
        });

        client.on("error", function(err) {
            if (
                err &&
                (err.code === "ECONNREFUSED" || err.code === "ENOENT" || err.code === "EAGAIN")
            ) {
                startServer();
            } else {
                logger.error("CLIENT SOCK ERR", client.userIds, err);
                // mock client.write
                client.write = function() {
                    logger.warn("CLIENT SOCK WRITE AFTER ERROR", client.userIds);
                };
                stream.emit("end");
            }
        });
    }
}

/**
 * Export the vfs extend API hook
 * Receive the user and project identification thorugh the vfs-extend server-verified options
 *
 * @param {Vfs}      vfs      - an instance of localfs.js
 * @param {Object}   options  - { user: {}, project: {} }
 * @param {Function} register - register the collab server API
 */
var exports = (module.exports = function(vfs, options, register) {
    var vfsClientMap = {};
    localfsAPI = vfs;

    if (options.nodePath) nodePath = options.nodePath;

    function connect(opts, callback) {
        var user = options.user;
        var environment = options.project;
        var clientId = opts.clientId;

        if (!user || !user.userId || !user.name || !environment || !environment.workspaceId)
            return callback(
                new Error("[OT] Invalid or incomplete collab options passed through extendOptions.")
            );

        if (!clientId || !opts.basePath)
            return callback(
                new Error(
                    "[OT] Invalid or incomplete collab opts passed on connect call: " +
                        opts.basePath +
                        " " +
                        clientId
                )
            );

        logger.debug("Connect received clientId:", clientId, "userId:", user.userId);

        PID = environment.workspaceId;
        basePath = Path.normalize(opts.basePath);

        var userIds = {
            userId: user.userId,
            name: user.name,
            clientId: clientId,
            fs: options.readonly ? "r" : "rw",
        };

        function cleanOldClient() {
            if (vfsClientMap[clientId]) {
                logger.error("Client attempted to create a second connection");
                dispose(clientId);
            }
        }

        cleanOldClient();

        initSocket(userIds, function(err, client, server) {
            if (err) {
                logger.error("initSocket failed", err);
                return callback(err instanceof Error ? err : new Error(err));
            }

            client.netServer = server;
            cleanOldClient();

            vfsClientMap[clientId] = client;
            logger.info("Added client to client map, clientId:", clientId);

            callback(null, {
                stream: client.clientStream,
                isMaster: isMaster && !!server,
            });
        });
    }

    /**
     * Broadcast a message to all clients (if we're collab master)
     * or just send it to the master (if we're collab slave).
     * Note that messages with e.g. type GENERIC_BROADCAST are forwarded
     * from the master to clients.
     */
    function broadcastOrSend(message) {
        if (clients && Object.keys(clients).length) return broadcast(message);
        for (var client in vfsClientMap) {
            send(client, message);
        }
    }

    function send(clientId, msg) {
        var client = vfsClientMap[clientId];
        if (client) client.write(JSON.stringify(msg) + "\0");
    }

    function dispose(clientId) {
        var client = vfsClientMap[clientId];
        if (!client) return;
        client.end();
        client.destroy();
        // TODO: properly handover
        // if (client.netServer)
        //    client.netServer.close();
        delete vfsClientMap[clientId];
    }

    /**
     * Get a `Document` from the database given its path
     * @param {String}   path the document path to query the database with
     * @param [{String}] attributes - optional
     * @param {Function} callback
     * @param {Object} callback.err
     * @param {Object} callback.result   The result, or null if getDocument() failed (might even though err is null)
     */
    function getDocument(path, attributes, callback) {
        if (!Document) {
            logger.info("Initializing collab db for read access");
            return initDB(true, getDocument.bind(null, path, attributes, callback));
        }
        Store.getDocument(path, attributes, callback);
    }

    register(null, {
        connect: connect,
        send: send,
        dispose: dispose,
        getDocument: getDocument,
        getDiffToLatestRevision: getDiffToLatestRevision,
        emitter: emitter,
        broadcastOrSend: broadcastOrSend,
    });
});

// export for testing
exports.Store = Store;
exports.compressDocument = compressDocument;
exports.checkDBCorruption = checkDBCorruption;
exports.areOperationsMirrored = areOperationsMirrored;
exports.hashString = hashString;
exports.removeNoopOperations = removeNoopOperations;
exports.logger = logger;
exports.operations = operations;
exports.handleChatMessage = handleChatMessage;
exports.handleClearChat = handleClearChat;
exports.handleGetRevisions = handleGetRevisions;
exports.initVfsWatcher = initVfsWatcher;

var DIFF_EQUAL = 0;
var DIFF_INSERT = 1;
var DIFF_DELETE = -1;
var diff_match_patch = require("./diff_match_patch");

// Copied from async
// Can be generically used in many scenarios
var async = (function() {
    function forEachSeries(arr, iterator, callback) {
        callback = callback || function() {};
        if (!arr.length) {
            return callback();
        }
        var completed = 0;
        var iterate = function() {
            iterator(arr[completed], function(err) {
                if (err) {
                    callback(err);
                    callback = function() {};
                } else {
                    completed += 1;
                    if (completed === arr.length) {
                        callback(null);
                    } else {
                        iterate();
                    }
                }
            });
        };
        iterate();
    }

    function series(arr, callback) {
        forEachSeries(
            arr,
            function(fn, next) {
                fn.call(null, function(err) {
                    if (err) return callback(err);
                    next();
                });
            },
            callback
        );
    }

    return {
        series: series,
        forEachSeries: forEachSeries,
    };
})();

// Copied from https://github.com/gjtorikian/isBinaryFile
function isBinaryFile(file, callback) {
    var max_bytes = 512;
    exists(file, function(exists) {
        if (!exists) return callback(null, false);

        Fs.open(file, "r", function(err, descriptor) {
            if (err) return callback(err);
            var bytes = new Buffer(max_bytes);
            // Read the file with no encoding for raw buffer access.
            Fs.read(descriptor, bytes, 0, bytes.length, 0, function(err, size, bytes) {
                Fs.close(descriptor, function(err2) {
                    if (err || err2) return callback(err || err2);
                    return callback(null, isBinaryCheck(size, bytes));
                });
            });
        });
    });

    function isBinaryCheck(size, bytes) {
        if (size === 0) return false;

        var suspicious_bytes = 0;
        var total_bytes = Math.min(size, max_bytes);

        if (size >= 3 && bytes[0] == 0xef && bytes[1] == 0xbb && bytes[2] == 0xbf) {
            // UTF-8 BOM. This isn't binary.
            return false;
        }

        for (var i = 0; i < total_bytes; i++) {
            if (bytes[i] === 0) {
                // NULL byte--it's binary!
                return true;
            } else if ((bytes[i] < 7 || bytes[i] > 14) && (bytes[i] < 32 || bytes[i] > 127)) {
                // UTF-8 detection
                if (bytes[i] > 191 && bytes[i] < 224 && i + 1 < total_bytes) {
                    i++;
                    if (bytes[i] < 192) {
                        continue;
                    }
                } else if (bytes[i] > 223 && bytes[i] < 239 && i + 2 < total_bytes) {
                    i++;
                    if (bytes[i] < 192 && bytes[i + 1] < 192) {
                        i++;
                        continue;
                    }
                }
                suspicious_bytes++;
                // Read at least 32 bytes before making a decision
                if (i > 32 && (suspicious_bytes * 100) / total_bytes > 10) {
                    return true;
                }
            }
        }

        if ((suspicious_bytes * 100) / total_bytes > 10) {
            return true;
        }

        return false;
    }
}

function isVeryLargeFile(file, contents, callback) {
    exists(file, function(exists) {
        if (!exists) return callback(new Error("File doesn't exist."));

        Fs.stat(file, function(err, stat) {
            if (err) return callback(err);

            callback(null, stat.size > 1024 * 1024 || (contents && contents.length > 1024 * 1024));
        });
    });
}

});


define('c9.ide.collab/server/diff_match_patch', function (module, exports, require) {

/* Google diff match patch library: https://code.google.com/p/google-diff-match-patch/ */

function diff_match_patch() {
    this.Diff_Timeout = 1;
    this.Diff_EditCost = 4;
    this.Match_Threshold = 0.5;
    this.Match_Distance = 1e3;
    this.Patch_DeleteThreshold = 0.5;
    this.Patch_Margin = 4;
    this.Match_MaxBits = 32;
}
diff_match_patch.prototype.diff_main = function(a, b, c, d) {
    "undefined" == typeof d &&
        (d =
            0 >= this.Diff_Timeout
                ? Number.MAX_VALUE
                : new Date().getTime() + 1e3 * this.Diff_Timeout);
    if (null == a || null == b) throw Error("Null input. (diff_main)");
    if (a == b) return a ? [[0, a]] : [];
    "undefined" == typeof c && (c = !0);
    var e = c,
        f = this.diff_commonPrefix(a, b),
        c = a.substring(0, f),
        a = a.substring(f),
        b = b.substring(f),
        f = this.diff_commonSuffix(a, b),
        g = a.substring(a.length - f),
        a = a.substring(0, a.length - f),
        b = b.substring(0, b.length - f),
        a = this.diff_compute_(a, b, e, d);
    c && a.unshift([0, c]);
    g && a.push([0, g]);
    this.diff_cleanupMerge(a);
    return a;
};
diff_match_patch.prototype.diff_compute_ = function(a, b, c, d) {
    if (!a) return [[1, b]];
    if (!b) return [[-1, a]];
    var e = a.length > b.length ? a : b,
        f = a.length > b.length ? b : a,
        g = e.indexOf(f);
    if (-1 != g)
        return (
            (c = [
                [1, e.substring(0, g)],
                [0, f],
                [1, e.substring(g + f.length)],
            ]),
            a.length > b.length && (c[0][0] = c[2][0] = -1),
            c
        );
    if (1 == f.length)
        return [
            [-1, a],
            [1, b],
        ];
    return (e = this.diff_halfMatch_(a, b))
        ? ((f = e[0]),
          (a = e[1]),
          (g = e[2]),
          (b = e[3]),
          (e = e[4]),
          (f = this.diff_main(f, g, c, d)),
          (c = this.diff_main(a, b, c, d)),
          f.concat([[0, e]], c))
        : c && 100 < a.length && 100 < b.length
        ? this.diff_lineMode_(a, b, d)
        : this.diff_bisect_(a, b, d);
};
diff_match_patch.prototype.diff_lineMode_ = function(a, b, c) {
    var d = this.diff_linesToChars_(a, b),
        a = d.chars1,
        b = d.chars2,
        d = d.lineArray,
        a = this.diff_main(a, b, !1, c);
    this.diff_charsToLines_(a, d);
    this.diff_cleanupSemantic(a);
    a.push([0, ""]);
    for (var e = (d = b = 0), f = "", g = ""; b < a.length; ) {
        switch (a[b][0]) {
            case 1:
                e++;
                g += a[b][1];
                break;
            case -1:
                d++;
                f += a[b][1];
                break;
            case 0:
                if (1 <= d && 1 <= e) {
                    a.splice(b - d - e, d + e);
                    b = b - d - e;
                    d = this.diff_main(f, g, !1, c);
                    for (e = d.length - 1; 0 <= e; e--) a.splice(b, 0, d[e]);
                    b += d.length;
                }
                d = e = 0;
                g = f = "";
        }
        b++;
    }
    a.pop();
    return a;
};
diff_match_patch.prototype.diff_bisect_ = function(a, b, c) {
    for (
        var d = a.length,
            e = b.length,
            f = Math.ceil((d + e) / 2),
            g = f,
            h = 2 * f,
            j = Array(h),
            i = Array(h),
            k = 0;
        k < h;
        k++
    )
        (j[k] = -1), (i[k] = -1);
    j[g + 1] = 0;
    i[g + 1] = 0;
    for (
        var k = d - e, p = 0 != k % 2, q = 0, s = 0, o = 0, v = 0, u = 0;
        u < f && !(new Date().getTime() > c);
        u++
    ) {
        for (var n = -u + q; n <= u - s; n += 2) {
            var l = g + n,
                m;
            m = n == -u || (n != u && j[l - 1] < j[l + 1]) ? j[l + 1] : j[l - 1] + 1;
            for (var r = m - n; m < d && r < e && a.charAt(m) == b.charAt(r); ) m++, r++;
            j[l] = m;
            if (m > d) s += 2;
            else if (r > e) q += 2;
            else if (p && ((l = g + k - n), 0 <= l && l < h && -1 != i[l])) {
                var t = d - i[l];
                if (m >= t) return this.diff_bisectSplit_(a, b, m, r, c);
            }
        }
        for (n = -u + o; n <= u - v; n += 2) {
            l = g + n;
            t = n == -u || (n != u && i[l - 1] < i[l + 1]) ? i[l + 1] : i[l - 1] + 1;
            for (m = t - n; t < d && m < e && a.charAt(d - t - 1) == b.charAt(e - m - 1); )
                t++, m++;
            i[l] = t;
            if (t > d) v += 2;
            else if (m > e) o += 2;
            else if (
                !p &&
                ((l = g + k - n),
                0 <= l && l < h && -1 != j[l] && ((m = j[l]), (r = g + m - l), (t = d - t), m >= t))
            )
                return this.diff_bisectSplit_(a, b, m, r, c);
        }
    }
    return [
        [-1, a],
        [1, b],
    ];
};
diff_match_patch.prototype.diff_bisectSplit_ = function(a, b, c, d, e) {
    var f = a.substring(0, c),
        g = b.substring(0, d),
        a = a.substring(c),
        b = b.substring(d),
        f = this.diff_main(f, g, !1, e),
        e = this.diff_main(a, b, !1, e);
    return f.concat(e);
};
diff_match_patch.prototype.diff_linesToChars_ = function(a, b) {
    function c(a) {
        for (var b = "", c = 0, f = -1, g = d.length; f < a.length - 1; ) {
            f = a.indexOf("\n", c);
            -1 == f && (f = a.length - 1);
            var q = a.substring(c, f + 1),
                c = f + 1;
            (e.hasOwnProperty
              ? e.hasOwnProperty(q)
              : void 0 !== e[q])
                ? (b += String.fromCharCode(e[q]))
                : ((b += String.fromCharCode(g)), (e[q] = g), (d[g++] = q));
        }
        return b;
    }
    var d = [],
        e = {};
    d[0] = "";
    var f = c(a),
        g = c(b);
    return {chars1: f, chars2: g, lineArray: d};
};
diff_match_patch.prototype.diff_charsToLines_ = function(a, b) {
    for (var c = 0; c < a.length; c++) {
        for (var d = a[c][1], e = [], f = 0; f < d.length; f++) e[f] = b[d.charCodeAt(f)];
        a[c][1] = e.join("");
    }
};
diff_match_patch.prototype.diff_commonPrefix = function(a, b) {
    if (!a || !b || a.charAt(0) != b.charAt(0)) return 0;
    for (var c = 0, d = Math.min(a.length, b.length), e = d, f = 0; c < e; )
        a.substring(f, e) == b.substring(f, e) ? (f = c = e) : (d = e),
            (e = Math.floor((d - c) / 2 + c));
    return e;
};
diff_match_patch.prototype.diff_commonSuffix = function(a, b) {
    if (!a || !b || a.charAt(a.length - 1) != b.charAt(b.length - 1)) return 0;
    for (var c = 0, d = Math.min(a.length, b.length), e = d, f = 0; c < e; )
        a.substring(a.length - e, a.length - f) == b.substring(b.length - e, b.length - f)
            ? (f = c = e)
            : (d = e),
            (e = Math.floor((d - c) / 2 + c));
    return e;
};
diff_match_patch.prototype.diff_commonOverlap_ = function(a, b) {
    var c = a.length,
        d = b.length;
    if (0 == c || 0 == d) return 0;
    c > d ? (a = a.substring(c - d)) : c < d && (b = b.substring(0, c));
    c = Math.min(c, d);
    if (a == b) return c;
    for (var d = 0, e = 1; ; ) {
        var f = a.substring(c - e),
            f = b.indexOf(f);
        if (-1 == f) return d;
        e += f;
        if (0 == f || a.substring(c - e) == b.substring(0, e)) (d = e), e++;
    }
};
diff_match_patch.prototype.diff_halfMatch_ = function(a, b) {
    function c(a, b, c) {
        for (
            var d = a.substring(c, c + Math.floor(a.length / 4)), e = -1, g = "", h, j, n, l;
            -1 != (e = b.indexOf(d, e + 1));

        ) {
            var m = f.diff_commonPrefix(a.substring(c), b.substring(e)),
                r = f.diff_commonSuffix(a.substring(0, c), b.substring(0, e));
            g.length < r + m &&
                ((g = b.substring(e - r, e) + b.substring(e, e + m)),
                (h = a.substring(0, c - r)),
                (j = a.substring(c + m)),
                (n = b.substring(0, e - r)),
                (l = b.substring(e + m)));
        }
        return 2 * g.length >= a.length ? [h, j, n, l, g] : null;
    }
    if (0 >= this.Diff_Timeout) return null;
    var d = a.length > b.length ? a : b,
        e = a.length > b.length ? b : a;
    if (4 > d.length || 2 * e.length < d.length) return null;
    var f = this,
        g = c(d, e, Math.ceil(d.length / 4)),
        d = c(d, e, Math.ceil(d.length / 2)),
        h;
    if (!g && !d) return null;
    h = d ? (g ? (g[4].length > d[4].length ? g : d) : d) : g;
    var j;
    a.length > b.length
        ? ((g = h[0]), (d = h[1]), (e = h[2]), (j = h[3]))
        : ((e = h[0]), (j = h[1]), (g = h[2]), (d = h[3]));
    h = h[4];
    return [g, d, e, j, h];
};
diff_match_patch.prototype.diff_cleanupSemantic = function(a) {
    for (var b = !1, c = [], d = 0, e = null, f = 0, g = 0, h = 0, j = 0, i = 0; f < a.length; )
        0 == a[f][0]
            ? ((c[d++] = f), (g = j), (h = i), (i = j = 0), (e = a[f][1]))
            : (1 == a[f][0] ? (j += a[f][1].length) : (i += a[f][1].length),
              e &&
                  e.length <= Math.max(g, h) &&
                  e.length <= Math.max(j, i) &&
                  (a.splice(c[d - 1], 0, [-1, e]),
                  (a[c[d - 1] + 1][0] = 1),
                  d--,
                  d--,
                  (f = 0 < d ? c[d - 1] : -1),
                  (i = j = h = g = 0),
                  (e = null),
                  (b = !0))),
            f++;
    b && this.diff_cleanupMerge(a);
    this.diff_cleanupSemanticLossless(a);
    for (f = 1; f < a.length; ) {
        if (-1 == a[f - 1][0] && 1 == a[f][0]) {
            b = a[f - 1][1];
            c = a[f][1];
            d = this.diff_commonOverlap_(b, c);
            e = this.diff_commonOverlap_(c, b);
            if (d >= e) {
                if (d >= b.length / 2 || d >= c.length / 2)
                    a.splice(f, 0, [0, c.substring(0, d)]),
                        (a[f - 1][1] = b.substring(0, b.length - d)),
                        (a[f + 1][1] = c.substring(d)),
                        f++;
            } else if (e >= b.length / 2 || e >= c.length / 2)
                a.splice(f, 0, [0, b.substring(0, e)]),
                    (a[f - 1][0] = 1),
                    (a[f - 1][1] = c.substring(0, c.length - e)),
                    (a[f + 1][0] = -1),
                    (a[f + 1][1] = b.substring(e)),
                    f++;
            f++;
        }
        f++;
    }
};
diff_match_patch.prototype.diff_cleanupSemanticLossless = function(a) {
    function b(a, b) {
        if (!a || !b) return 6;
        var c = a.charAt(a.length - 1),
            d = b.charAt(0),
            e = c.match(diff_match_patch.nonAlphaNumericRegex_),
            f = d.match(diff_match_patch.nonAlphaNumericRegex_),
            g = e && c.match(diff_match_patch.whitespaceRegex_),
            h = f && d.match(diff_match_patch.whitespaceRegex_),
            c = g && c.match(diff_match_patch.linebreakRegex_),
            d = h && d.match(diff_match_patch.linebreakRegex_),
            i = c && a.match(diff_match_patch.blanklineEndRegex_),
            j = d && b.match(diff_match_patch.blanklineStartRegex_);
        return i || j ? 5 : c || d ? 4 : e && !g && h ? 3 : g || h ? 2 : e || f ? 1 : 0;
    }
    for (var c = 1; c < a.length - 1; ) {
        if (0 == a[c - 1][0] && 0 == a[c + 1][0]) {
            var d = a[c - 1][1],
                e = a[c][1],
                f = a[c + 1][1],
                g = this.diff_commonSuffix(d, e);
            if (g)
                var h = e.substring(e.length - g),
                    d = d.substring(0, d.length - g),
                    e = h + e.substring(0, e.length - g),
                    f = h + f;
            for (var g = d, h = e, j = f, i = b(d, e) + b(e, f); e.charAt(0) === f.charAt(0); ) {
                var d = d + e.charAt(0),
                    e = e.substring(1) + f.charAt(0),
                    f = f.substring(1),
                    k = b(d, e) + b(e, f);
                k >= i && ((i = k), (g = d), (h = e), (j = f));
            }
            a[c - 1][1] != g &&
                (g ? (a[c - 1][1] = g) : (a.splice(c - 1, 1), c--),
                (a[c][1] = h),
                j ? (a[c + 1][1] = j) : (a.splice(c + 1, 1), c--));
        }
        c++;
    }
};
diff_match_patch.nonAlphaNumericRegex_ = /[^a-zA-Z0-9]/;
diff_match_patch.whitespaceRegex_ = /\s/;
diff_match_patch.linebreakRegex_ = /[\r\n]/;
diff_match_patch.blanklineEndRegex_ = /\n\r?\n$/;
diff_match_patch.blanklineStartRegex_ = /^\r?\n\r?\n/;
diff_match_patch.prototype.diff_cleanupEfficiency = function(a) {
    for (
        var b = !1, c = [], d = 0, e = null, f = 0, g = !1, h = !1, j = !1, i = !1;
        f < a.length;

    ) {
        if (0 == a[f][0])
            a[f][1].length < this.Diff_EditCost && (j || i)
                ? ((c[d++] = f), (g = j), (h = i), (e = a[f][1]))
                : ((d = 0), (e = null)),
                (j = i = !1);
        else if (
            (-1 == a[f][0] ? (i = !0) : (j = !0),
            e && ((g && h && j && i) || (e.length < this.Diff_EditCost / 2 && 3 == g + h + j + i)))
        )
            a.splice(c[d - 1], 0, [-1, e]),
                (a[c[d - 1] + 1][0] = 1),
                d--,
                (e = null),
                g && h ? ((j = i = !0), (d = 0)) : (d--, (f = 0 < d ? c[d - 1] : -1), (j = i = !1)),
                (b = !0);
        f++;
    }
    b && this.diff_cleanupMerge(a);
};
diff_match_patch.prototype.diff_cleanupMerge = function(a) {
    a.push([0, ""]);
    for (var b = 0, c = 0, d = 0, e = "", f = "", g; b < a.length; )
        switch (a[b][0]) {
            case 1:
                d++;
                f += a[b][1];
                b++;
                break;
            case -1:
                c++;
                e += a[b][1];
                b++;
                break;
            case 0:
                1 < c + d
                    ? (0 !== c &&
                          0 !== d &&
                          ((g = this.diff_commonPrefix(f, e)),
                          0 !== g &&
                              (0 < b - c - d && 0 == a[b - c - d - 1][0]
                                  ? (a[b - c - d - 1][1] += f.substring(0, g))
                                  : (a.splice(0, 0, [0, f.substring(0, g)]), b++),
                              (f = f.substring(g)),
                              (e = e.substring(g))),
                          (g = this.diff_commonSuffix(f, e)),
                          0 !== g &&
                              ((a[b][1] = f.substring(f.length - g) + a[b][1]),
                              (f = f.substring(0, f.length - g)),
                              (e = e.substring(0, e.length - g)))),
                      0 === c
                          ? a.splice(b - d, c + d, [1, f])
                          : 0 === d
                          ? a.splice(b - c, c + d, [-1, e])
                          : a.splice(b - c - d, c + d, [-1, e], [1, f]),
                      (b = b - c - d + (c ? 1 : 0) + (d ? 1 : 0) + 1))
                    : 0 !== b && 0 == a[b - 1][0]
                    ? ((a[b - 1][1] += a[b][1]), a.splice(b, 1))
                    : b++,
                    (c = d = 0),
                    (f = e = "");
        }
    "" === a[a.length - 1][1] && a.pop();
    c = !1;
    for (b = 1; b < a.length - 1; )
        0 == a[b - 1][0] &&
            0 == a[b + 1][0] &&
            (a[b][1].substring(a[b][1].length - a[b - 1][1].length) == a[b - 1][1]
                ? ((a[b][1] =
                      a[b - 1][1] + a[b][1].substring(0, a[b][1].length - a[b - 1][1].length)),
                  (a[b + 1][1] = a[b - 1][1] + a[b + 1][1]),
                  a.splice(b - 1, 1),
                  (c = !0))
                : a[b][1].substring(0, a[b + 1][1].length) == a[b + 1][1] &&
                  ((a[b - 1][1] += a[b + 1][1]),
                  (a[b][1] = a[b][1].substring(a[b + 1][1].length) + a[b + 1][1]),
                  a.splice(b + 1, 1),
                  (c = !0))),
            b++;
    c && this.diff_cleanupMerge(a);
};
diff_match_patch.prototype.diff_xIndex = function(a, b) {
    var c = 0,
        d = 0,
        e = 0,
        f = 0,
        g;
    for (g = 0; g < a.length; g++) {
        1 !== a[g][0] && (c += a[g][1].length);
        -1 !== a[g][0] && (d += a[g][1].length);
        if (c > b) break;
        e = c;
        f = d;
    }
    return a.length != g && -1 === a[g][0] ? f : f + (b - e);
};
diff_match_patch.prototype.diff_prettyHtml = function(a) {
    for (var b = [], c = /&/g, d = /</g, e = />/g, f = /\n/g, g = 0; g < a.length; g++) {
        var h = a[g][0],
            j = a[g][1],
            j = j
                .replace(c, "&amp;")
                .replace(d, "&lt;")
                .replace(e, "&gt;")
                .replace(f, "&para;<br>");
        switch (h) {
            case 1:
                b[g] = '<ins style="background:#e6ffe6;">' + j + "</ins>";
                break;
            case -1:
                b[g] = '<del style="background:#ffe6e6;">' + j + "</del>";
                break;
            case 0:
                b[g] = "<span>" + j + "</span>";
        }
    }
    return b.join("");
};
diff_match_patch.prototype.diff_text1 = function(a) {
    for (var b = [], c = 0; c < a.length; c++) 1 !== a[c][0] && (b[c] = a[c][1]);
    return b.join("");
};
diff_match_patch.prototype.diff_text2 = function(a) {
    for (var b = [], c = 0; c < a.length; c++) -1 !== a[c][0] && (b[c] = a[c][1]);
    return b.join("");
};
diff_match_patch.prototype.diff_levenshtein = function(a) {
    for (var b = 0, c = 0, d = 0, e = 0; e < a.length; e++) {
        var f = a[e][0],
            g = a[e][1];
        switch (f) {
            case 1:
                c += g.length;
                break;
            case -1:
                d += g.length;
                break;
            case 0:
                (b += Math.max(c, d)), (d = c = 0);
        }
    }
    return (b += Math.max(c, d));
};
diff_match_patch.prototype.diff_toDelta = function(a) {
    for (var b = [], c = 0; c < a.length; c++)
        switch (a[c][0]) {
            case 1:
                b[c] = "+" + encodeURI(a[c][1]);
                break;
            case -1:
                b[c] = "-" + a[c][1].length;
                break;
            case 0:
                b[c] = "=" + a[c][1].length;
        }
    return b.join("\t").replace(/%20/g, " ");
};
diff_match_patch.prototype.diff_fromDelta = function(a, b) {
    for (var c = [], d = 0, e = 0, f = b.split(/\t/g), g = 0; g < f.length; g++) {
        var h = f[g].substring(1);
        switch (f[g].charAt(0)) {
            case "+":
                try {
                    c[d++] = [1, decodeURI(h)];
                } catch (j) {
                    throw Error("Illegal escape in diff_fromDelta: " + h);
                }
                break;
            case "-":
            case "=":
                var i = parseInt(h, 10);
                if (isNaN(i) || 0 > i) throw Error("Invalid number in diff_fromDelta: " + h);
                h = a.substring(e, (e += i));
                "=" == f[g].charAt(0) ? (c[d++] = [0, h]) : (c[d++] = [-1, h]);
                break;
            default:
                if (f[g]) throw Error("Invalid diff operation in diff_fromDelta: " + f[g]);
        }
    }
    if (e != a.length)
        throw Error(
            "Delta length (" + e + ") does not equal source text length (" + a.length + ")."
        );
    return c;
};
diff_match_patch.prototype.match_main = function(a, b, c) {
    if (null == a || null == b || null == c) throw Error("Null input. (match_main)");
    c = Math.max(0, Math.min(c, a.length));
    return a == b
        ? 0
        : a.length
        ? a.substring(c, c + b.length) == b
            ? c
            : this.match_bitap_(a, b, c)
        : -1;
};
diff_match_patch.prototype.match_bitap_ = function(a, b, c) {
    function d(a, d) {
        var e = a / b.length,
            g = Math.abs(c - d);
        return !f.Match_Distance ? (g ? 1 : e) : e + g / f.Match_Distance;
    }
    if (b.length > this.Match_MaxBits) throw Error("Pattern too long for this browser.");
    var e = this.match_alphabet_(b),
        f = this,
        g = this.Match_Threshold,
        h = a.indexOf(b, c);
    -1 != h &&
        ((g = Math.min(d(0, h), g)),
        (h = a.lastIndexOf(b, c + b.length)),
        -1 != h && (g = Math.min(d(0, h), g)));
    for (
        var j = 1 << (b.length - 1), h = -1, i, k, p = b.length + a.length, q, s = 0;
        s < b.length;
        s++
    ) {
        i = 0;
        for (k = p; i < k; )
            d(s, c + k) <= g ? (i = k) : (p = k), (k = Math.floor((p - i) / 2 + i));
        p = k;
        i = Math.max(1, c - k + 1);
        var o = Math.min(c + k, a.length) + b.length;
        k = Array(o + 2);
        for (k[o + 1] = (1 << s) - 1; o >= i; o--) {
            var v = e[a.charAt(o - 1)];
            k[o] =
                0 === s
                    ? ((k[o + 1] << 1) | 1) & v
                    : (((k[o + 1] << 1) | 1) & v) | ((q[o + 1] | q[o]) << 1) | 1 | q[o + 1];
            if (k[o] & j && ((v = d(s, o - 1)), v <= g))
                if (((g = v), (h = o - 1), h > c)) i = Math.max(1, 2 * c - h);
                else break;
        }
        if (d(s + 1, c) > g) break;
        q = k;
    }
    return h;
};
diff_match_patch.prototype.match_alphabet_ = function(a) {
    for (var b = {}, c = 0; c < a.length; c++) b[a.charAt(c)] = 0;
    for (c = 0; c < a.length; c++) b[a.charAt(c)] |= 1 << (a.length - c - 1);
    return b;
};
diff_match_patch.prototype.patch_addContext_ = function(a, b) {
    if (0 != b.length) {
        for (
            var c = b.substring(a.start2, a.start2 + a.length1), d = 0;
            b.indexOf(c) != b.lastIndexOf(c) &&
            c.length < this.Match_MaxBits - this.Patch_Margin - this.Patch_Margin;

        )
            (d += this.Patch_Margin), (c = b.substring(a.start2 - d, a.start2 + a.length1 + d));
        d += this.Patch_Margin;
        (c = b.substring(a.start2 - d, a.start2)) && a.diffs.unshift([0, c]);
        (d = b.substring(a.start2 + a.length1, a.start2 + a.length1 + d)) && a.diffs.push([0, d]);
        a.start1 -= c.length;
        a.start2 -= c.length;
        a.length1 += c.length + d.length;
        a.length2 += c.length + d.length;
    }
};
diff_match_patch.prototype.patch_make = function(a, b, c) {
    var d;
    if ("string" == typeof a && "string" == typeof b && "undefined" == typeof c)
        (d = a),
            (b = this.diff_main(d, b, !0)),
            2 < b.length && (this.diff_cleanupSemantic(b), this.diff_cleanupEfficiency(b));
    else if (a && "object" == typeof a && "undefined" == typeof b && "undefined" == typeof c)
        (b = a), (d = this.diff_text1(b));
    else if ("string" == typeof a && b && "object" == typeof b && "undefined" == typeof c) d = a;
    else if ("string" == typeof a && "string" == typeof b && c && "object" == typeof c)
        (d = a), (b = c);
    else throw Error("Unknown call format to patch_make.");
    if (0 === b.length) return [];
    for (
        var c = [], a = new diff_match_patch.patch_obj(), e = 0, f = 0, g = 0, h = d, j = 0;
        j < b.length;
        j++
    ) {
        var i = b[j][0],
            k = b[j][1];
        if (!e && 0 !== i) (a.start1 = f), (a.start2 = g);
        switch (i) {
            case 1:
                a.diffs[e++] = b[j];
                a.length2 += k.length;
                d = d.substring(0, g) + k + d.substring(g);
                break;
            case -1:
                a.length1 += k.length;
                a.diffs[e++] = b[j];
                d = d.substring(0, g) + d.substring(g + k.length);
                break;
            case 0:
                k.length <= 2 * this.Patch_Margin && e && b.length != j + 1
                    ? ((a.diffs[e++] = b[j]), (a.length1 += k.length), (a.length2 += k.length))
                    : k.length >= 2 * this.Patch_Margin &&
                      e &&
                      (this.patch_addContext_(a, h),
                      c.push(a),
                      (a = new diff_match_patch.patch_obj()),
                      (e = 0),
                      (h = d),
                      (f = g));
        }
        1 !== i && (f += k.length);
        -1 !== i && (g += k.length);
    }
    e && (this.patch_addContext_(a, h), c.push(a));
    return c;
};
diff_match_patch.prototype.patch_deepCopy = function(a) {
    for (var b = [], c = 0; c < a.length; c++) {
        var d = a[c],
            e = new diff_match_patch.patch_obj();
        e.diffs = [];
        for (var f = 0; f < d.diffs.length; f++) e.diffs[f] = d.diffs[f].slice();
        e.start1 = d.start1;
        e.start2 = d.start2;
        e.length1 = d.length1;
        e.length2 = d.length2;
        b[c] = e;
    }
    return b;
};
diff_match_patch.prototype.patch_apply = function(a, b) {
    if (0 == a.length) return [b, []];
    var a = this.patch_deepCopy(a),
        c = this.patch_addPadding(a),
        b = c + b + c;
    this.patch_splitMax(a);
    for (var d = 0, e = [], f = 0; f < a.length; f++) {
        var g = a[f].start2 + d,
            h = this.diff_text1(a[f].diffs),
            j,
            i = -1;
        if (h.length > this.Match_MaxBits) {
            if (
                ((j = this.match_main(b, h.substring(0, this.Match_MaxBits), g)),
                -1 != j &&
                    ((i = this.match_main(
                        b,
                        h.substring(h.length - this.Match_MaxBits),
                        g + h.length - this.Match_MaxBits
                    )),
                    -1 == i || j >= i))
            )
                j = -1;
        } else j = this.match_main(b, h, g);
        if (-1 == j) (e[f] = !1), (d -= a[f].length2 - a[f].length1);
        else if (
            ((e[f] = !0),
            (d = j - g),
            (g = -1 == i ? b.substring(j, j + h.length) : b.substring(j, i + this.Match_MaxBits)),
            h == g)
        )
            b = b.substring(0, j) + this.diff_text2(a[f].diffs) + b.substring(j + h.length);
        else if (
            ((g = this.diff_main(h, g, !1)),
            h.length > this.Match_MaxBits &&
                this.diff_levenshtein(g) / h.length > this.Patch_DeleteThreshold)
        )
            e[f] = !1;
        else {
            this.diff_cleanupSemanticLossless(g);
            for (var h = 0, k, i = 0; i < a[f].diffs.length; i++) {
                var p = a[f].diffs[i];
                0 !== p[0] && (k = this.diff_xIndex(g, h));
                1 === p[0]
                    ? (b = b.substring(0, j + k) + p[1] + b.substring(j + k))
                    : -1 === p[0] &&
                      (b =
                          b.substring(0, j + k) +
                          b.substring(j + this.diff_xIndex(g, h + p[1].length)));
                -1 !== p[0] && (h += p[1].length);
            }
        }
    }
    b = b.substring(c.length, b.length - c.length);
    return [b, e];
};
diff_match_patch.prototype.patch_addPadding = function(a) {
    for (var b = this.Patch_Margin, c = "", d = 1; d <= b; d++) c += String.fromCharCode(d);
    for (d = 0; d < a.length; d++) (a[d].start1 += b), (a[d].start2 += b);
    var d = a[0],
        e = d.diffs;
    if (0 == e.length || 0 != e[0][0])
        e.unshift([0, c]), (d.start1 -= b), (d.start2 -= b), (d.length1 += b), (d.length2 += b);
    else if (b > e[0][1].length) {
        var f = b - e[0][1].length;
        e[0][1] = c.substring(e[0][1].length) + e[0][1];
        d.start1 -= f;
        d.start2 -= f;
        d.length1 += f;
        d.length2 += f;
    }
    d = a[a.length - 1];
    e = d.diffs;
    0 == e.length || 0 != e[e.length - 1][0]
        ? (e.push([0, c]), (d.length1 += b), (d.length2 += b))
        : b > e[e.length - 1][1].length &&
          ((f = b - e[e.length - 1][1].length),
          (e[e.length - 1][1] += c.substring(0, f)),
          (d.length1 += f),
          (d.length2 += f));
    return c;
};
diff_match_patch.prototype.patch_splitMax = function(a) {
    for (var b = this.Match_MaxBits, c = 0; c < a.length; c++)
        if (!(a[c].length1 <= b)) {
            var d = a[c];
            a.splice(c--, 1);
            for (var e = d.start1, f = d.start2, g = ""; 0 !== d.diffs.length; ) {
                var h = new diff_match_patch.patch_obj(),
                    j = !0;
                h.start1 = e - g.length;
                h.start2 = f - g.length;
                if ("" !== g) (h.length1 = h.length2 = g.length), h.diffs.push([0, g]);
                for (; 0 !== d.diffs.length && h.length1 < b - this.Patch_Margin; ) {
                    var g = d.diffs[0][0],
                        i = d.diffs[0][1];
                    1 === g
                        ? ((h.length2 += i.length),
                          (f += i.length),
                          h.diffs.push(d.diffs.shift()),
                          (j = !1))
                        : -1 === g && 1 == h.diffs.length && 0 == h.diffs[0][0] && i.length > 2 * b
                        ? ((h.length1 += i.length),
                          (e += i.length),
                          (j = !1),
                          h.diffs.push([g, i]),
                          d.diffs.shift())
                        : ((i = i.substring(0, b - h.length1 - this.Patch_Margin)),
                          (h.length1 += i.length),
                          (e += i.length),
                          0 === g ? ((h.length2 += i.length), (f += i.length)) : (j = !1),
                          h.diffs.push([g, i]),
                          i == d.diffs[0][1]
                              ? d.diffs.shift()
                              : (d.diffs[0][1] = d.diffs[0][1].substring(i.length)));
                }
                g = this.diff_text2(h.diffs);
                g = g.substring(g.length - this.Patch_Margin);
                i = this.diff_text1(d.diffs).substring(0, this.Patch_Margin);
                "" !== i &&
                    ((h.length1 += i.length),
                    (h.length2 += i.length),
                    0 !== h.diffs.length && 0 === h.diffs[h.diffs.length - 1][0]
                        ? (h.diffs[h.diffs.length - 1][1] += i)
                        : h.diffs.push([0, i]));
                j || a.splice(++c, 0, h);
            }
        }
};
diff_match_patch.prototype.patch_toText = function(a) {
    for (var b = [], c = 0; c < a.length; c++) b[c] = a[c];
    return b.join("");
};
diff_match_patch.prototype.patch_fromText = function(a) {
    var b = [];
    if (!a) return b;
    for (var a = a.split("\n"), c = 0, d = /^@@ -(\d+),?(\d*) \+(\d+),?(\d*) @@$/; c < a.length; ) {
        var e = a[c].match(d);
        if (!e) throw Error("Invalid patch string: " + a[c]);
        var f = new diff_match_patch.patch_obj();
        b.push(f);
        f.start1 = parseInt(e[1], 10);
        "" === e[2]
            ? (f.start1--, (f.length1 = 1))
            : "0" == e[2]
            ? (f.length1 = 0)
            : (f.start1--, (f.length1 = parseInt(e[2], 10)));
        f.start2 = parseInt(e[3], 10);
        "" === e[4]
            ? (f.start2--, (f.length2 = 1))
            : "0" == e[4]
            ? (f.length2 = 0)
            : (f.start2--, (f.length2 = parseInt(e[4], 10)));
        for (c++; c < a.length; ) {
            e = a[c].charAt(0);
            try {
                var g = decodeURI(a[c].substring(1));
            } catch (h) {
                throw Error("Illegal escape in patch_fromText: " + g);
            }
            if ("-" == e) f.diffs.push([-1, g]);
            else if ("+" == e) f.diffs.push([1, g]);
            else if (" " == e) f.diffs.push([0, g]);
            else if ("@" == e) break;
            else if ("" !== e) throw Error('Invalid patch mode "' + e + '" in: ' + g);
            c++;
        }
    }
    return b;
};
diff_match_patch.patch_obj = function() {
    this.diffs = [];
    this.start2 = this.start1 = null;
    this.length2 = this.length1 = 0;
};
diff_match_patch.patch_obj.prototype.toString = function() {
    var a, b;
    a =
        0 === this.length1
            ? this.start1 + ",0"
            : 1 == this.length1
            ? this.start1 + 1
            : this.start1 + 1 + "," + this.length1;
    b =
        0 === this.length2
            ? this.start2 + ",0"
            : 1 == this.length2
            ? this.start2 + 1
            : this.start2 + 1 + "," + this.length2;
    a = ["@@ -" + a + " +" + b + " @@\n"];
    var c;
    for (b = 0; b < this.diffs.length; b++) {
        switch (this.diffs[b][0]) {
            case 1:
                c = "+";
                break;
            case -1:
                c = "-";
                break;
            case 0:
                c = " ";
        }
        a[b + 1] = c + encodeURI(this.diffs[b][1]) + "\n";
    }
    return a.join("").replace(/%20/g, " ");
};

/* diff match patch end */
module.exports = diff_match_patch;

});


define('c9.vfs.client/ping-service.js', function (module, exports, require) {

module.exports = function(vfs, options, register) {
    register(null, {
        ping: function(payload, callback) {
            // We simply return the payload, while vfs-socket adds a time stamp
            callback(null, payload);
        },
    });
};

});


define('c9.vfs.client/store-service.js', function (module, exports, require) {

module.exports = function(vfs, options, register) {
    var storedData = {};

    function storeData(type, key, value) {
        if (!storedData[type]) storedData[type] = {};
        storedData[type][key] = value;
    }

    function removeData(type, key) {
        if (!storedData[type] || !storedData[type][key]) return;
        delete storedData[type][key];
    }

    function getData(type, callback) {
        return callback(storedData[type]);
    }

    register(null, {
        storeData: storeData,
        removeData: removeData,
        getData: getData,
    });
};

});


define('./slave', function (module, exports, require) {

/**
 * The slave function takes a vfsOptions config from a master, and is used to
 * kick off the vfs-worker on the environment. It assumes that all the plugins
 * required by the vfs-worker are already available to the node process
 * (responsibility of the bootstap.js code).
 *
 * One way of thinking about this function is that it's the main function of the
 * vfs-worker.
 *
 */
module.exports = function(config, callback) {
    process.title = "vfs-worker " + JSON.stringify(config);
    var Worker = require("@c9/vfs-socket/worker").Worker;
    var StreamTransport = require("@c9/smith").StreamTransport;
    var vfsLocal = require("@c9/vfs-local")(config);

    var worker = new Worker(vfsLocal);
    worker.connect(new StreamTransport([process.stdin, process.stdout]), callback);

    function onDisconnect() {
        process.removeListener("SIGINT", intHandler);
        process.removeListener("SIGTERM", termHandler);
        process.removeListener("uncaughtException", exceptionHandler);

        vfsLocal.killtree(process.pid, {}, function(err, pidlist) {
            if (err) {
                console.error(err.stack);
                process.exit();
            }
        });
    }

    if (config.idleConnectionTimeoutMilliseconds) {
        // SSH has a built in timeout that tears down the channel when it is idle
        // (data hasn't moved across it).
        //
        // In SSM, the model of the world looks like this:
        // customer's browser <--- websocket [A] ---> VFS <--- websocket [B] ---> MessageGatewayService <--- websocket [C] ---> customer's compute
        // When a customer's browser disconnects from VFS, websocket A and B are torn
        // down, but C remains alive.  The following idle connection timeout does the
        // same thing that SSH does, but for SSM.  It ensures that websocket C
        // is brought down gracefully, which allows the slave worker process tree to
        // also terminate gracefully.
        var idleConnectionTimeout = setTimeout(
            onDisconnect,
            config.idleConnectionTimeoutMilliseconds
        );
        process.stdin.on("data", function() {
            clearTimeout(idleConnectionTimeout);
            idleConnectionTimeout = setTimeout(
                onDisconnect,
                config.idleConnectionTimeoutMilliseconds
            );
        });
    }

    worker.on("disconnect", onDisconnect);

    process.on("SIGINT", intHandler);
    process.on("SIGTERM", termHandler);
    process.on("uncaughtException", exceptionHandler);

    function intHandler() {
        cleanup(new Error("Received unexpected signal: SIGINT"), 1);
    }

    function termHandler() {
        cleanup(new Error("Received unexpected signal: SIGTERM"), 2);
    }

    function exceptionHandler(err) {
        cleanup(err, 3);
    }

    function cleanup(err, code) {
        console.log(process.pid, "Unhandled exception", (err.message || err).toString(), err.stack);

        // give some time to send last packages
        setTimeout(function() {
            worker.disconnect(err);

            // give some time to close connection
            setTimeout(function() {
                process.exit(code);
            }, 500);
        }, 200);
    }
};

});


define('@c9/vfs-socket/worker', function (module, exports, require) {

var inherits = require('util').inherits;
var smith = require('@c9/smith');
var Agent = smith.Agent;
var Stream = require('stream').Stream;
var ApiHandler = require('./api-handler').ApiHandler;

exports.smith = smith;
exports.Worker = Worker;

// Worker is a smith.Agent that wraps the vfs api passed to it. It works in
// tandem with Consumer agents on the other side.
function Worker(vfs) {
    Agent.call(this, {

        // Endpoints for writable streams at meta.stream (and meta.process.stdin)
        write: write,
        end: end,

        // Endpoint for readable stream at meta.stream (and meta.process.{stdout,stderr})
        destroy: destroy,
        resume: resume,
        pause: pause,

        // Endpoints for readable streams at options.stream
        onData: onData,
        onEnd: onEnd,

        // Endpoint for writable streams at options.stream
        onClose: onClose,

        // Endpoints for processes at meta.process
        unref: unref,
        kill: kill,

        // Endpoints for processes at meta.pty
        resize: resize,

        // Endpoint for watchers at meta.watcher
        close: closeWatcher,

        // Endpoint for apis at meta.api
        call: call,

        // Endpoints for vfs itself
        subscribe: subscribe,
        unsubscribe: unsubscribe,
        emit: vfs.emit,

        // special vfs-socket api
        ping: ping,

        // Route other calls to the local vfs instance
        resolve:    route("resolve"),
        stat:       route("stat"),
        metadata:   route("metadata"),
        readfile:   route("readfile"),
        readdir:    route("readdir"),
        mkfile:     route("mkfile"),
        mkdir:      route("mkdir"),
        mkdirP:     route("mkdirP"),
        appendfile: route("appendfile"),
        rmfile:     route("rmfile"),
        rmdir:      route("rmdir"),
        rename:     route("rename"),
        copy:       route("copy"),
        chmod:      route("chmod"),
        symlink:    route("symlink"),
        watch:      route("watch"),
        connect:    route("connect"),
        spawn:      route("spawn"),
        killtree:   route("killtree"),
        pty:        route("pty"),
        tmux:       route("tmux"),
        execFile:   route("execFile"),
        extend:     route("extend"),
        unextend:   route("unextend"),
        use:        route("use"),

        env:        vfs.env,
    });

    var proxyStreams = {};
    var streams = {};
    var watchers = {};
    var processes = {};
    var handlers = {};
    var remote = this.remoteApi;
    var apiHandler = new ApiHandler({
        name: "worker",
        processCallback: processCallback,
        onBeforeStoredApiCall: wrapPingCall,
        remote: remote,
    });

    function subscribe(name, callback) {
        handlers[name] = function (value) {
            remote.onEvent && remote.onEvent(name, value);
        };
        vfs.on(name, handlers[name], callback);
    }

    function unsubscribe(name, callback) {
        var handler = handlers[name];
        if (!handler) return;
        delete handlers[name];
        vfs.off(name, handler, callback);
    }

    // Resume readable streams that we paused when the channel drains
    // Forward drain events to all the writable proxy streams.
    this.on("drain", function () {
        Object.keys(streams).forEach(function (id) {
            var stream = streams[id];
            if (stream && stream.readable && stream.resume) stream.resume();
        });
        Object.keys(proxyStreams).forEach(function (id) {
            var stream = proxyStreams[id];
            if (stream.writable) stream.emit("drain");
        });
    });

    // Pause stream if trnasport starts buffering
    this.on("buffering", function() {
        Object.keys(streams).forEach(function(id) {
            var stream = streams[id];
            if (stream.readable && stream.pause) stream.pause();
        });
    });

    // Cleanup streams, proxy streams, proxy processes, and proxy apis on disconnect.
    this.on("disconnect", function (err) {
        if (!err) {
            err = new Error("EDISCONNECT: vfs socket disconnected");
            err.code = "EDISCONNECT";
        }
        Object.keys(processes).forEach(function (pid) {
            var process = processes[pid];
            if (process &&!process.unreffed)
                process.kill();
            delete processes[pid];
        });
        Object.keys(streams).forEach(function (id) {
            var stream = streams[id];
            stream.emit("close", err);
        });
        Object.keys(proxyStreams).forEach(onClose);
        Object.keys(watchers).forEach(function (id) {
            var watcher = watchers[id];
            delete watchers[id];
            watcher.close();
        });
    });

    function makeStreamProxy(token) {
        var stream = new Stream();
        var id = token.id;
        stream.id = id;
        proxyStreams[id] = stream;
        if (token.hasOwnProperty("readable")) stream.readable = token.readable;
        if (token.hasOwnProperty("writable")) stream.writable = token.writable;

        if (stream.writable) {
            stream.write = function (chunk) {
                return remote.write(id, chunk);
            };
            stream.end = function (chunk) {
                if (chunk) remote.end(id, chunk);
                else remote.end(id);
            };
        }
        if (stream.readable) {
            stream.destroy = function () {
                remote.destroy(id);
            };
            stream.resume = function () {
                remote.resume(id);
            };
            stream.pause = function () {
                remote.pause(id);
            };
        }

        return stream;
    }

    var nextStreamID = 1;
    function storeStream(stream) {
        if (stream.token)
            return stream.token;

        nextStreamID = (nextStreamID + 1) % 10000;
        while (streams.hasOwnProperty(nextStreamID)) { nextStreamID = (nextStreamID + 1) % 10000; }
        var id = nextStreamID;
        streams[id] = stream;
        stream.id = id;
        stream.on("error", function(err) {
            remote.onError && remote.onError(id, err);
        });
        if (stream.readable) {
            stream.on("data", function (chunk) {
                // remote can be disconnected while data still comes in
                if (remote.onData && remote.onData(id, chunk) === false) {
                    stream.pause && stream.pause();
                }
            });
            stream.on("end", function (chunk) {
                delete streams[id];
                remote.onEnd && remote.onEnd(id, chunk);
            });
        }
        stream.on("close", function () {
            delete streams[id];
            if (remote.onClose)
                remote.onClose(id);
        });
        var token = {id: id};
        stream.token = token;
        if (stream.hasOwnProperty("readable")) token.readable = stream.readable;
        if (stream.hasOwnProperty("writable")) token.writable = stream.writable;
        return token;
    }

    function storeProcess(process, onlyPid) {
        var pid = process.pid;
        if (processes.token)
            return onlyPid ? process.pid : process.token;

        processes[pid] = process;
        process.on("exit", function (code, signal) {
            delete processes[pid];
            remote.onExit && remote.onExit(pid, code, signal);
        });
        process.on("close", function (code, signal) {
            delete processes[pid];
            if (!onlyPid) {
                delete streams[process.stdout.id];
                delete streams[process.stderr.id];
                delete streams[process.stdin.id];
            }
            remote.onProcessClose && remote.onProcessClose(pid, code, signal);
        });

        process.kill = function(code, callback) {
            vfs.killtree(pid, {
                code: code
            }, callback || function() {});
        };

        var token = {pid: pid};
        process.token = token;

        if (onlyPid)
            return pid;

        token.stdin = storeStream(process.stdin);
        token.stdout = storeStream(process.stdout);
        token.stderr = storeStream(process.stderr);
        return token;
    }

    function storePty(pty) {
        if (!pty || processes[pty.pid] == pty) // Pty is returned twice
            return pty && pty.token;

        var pid = storeProcess(pty, true); delete pty.token;

        if (!pty.resume && pty.socket && pty.socket.resume)
            pty.resume = pty.socket.resume.bind(pty.socket);

        if (!pty.pause && pty.socket && pty.socket.pause)
            pty.pause = pty.socket.pause.bind(pty.socket);

        var token = storeStream(pty); delete pty.token;
        token.pid = pid;
        pty.token = token;

        pty.on("kill", function () {
            remote.onPtyKill && remote.onPtyKill(pid);
        });

        return token;
    }

    var nextWatcherID = 1;
    function storeWatcher(watcher) {
        do {
            nextWatcherID = (nextWatcherID + 1) % 10000;
        } while (watchers.hasOwnProperty(nextWatcherID));
        var id = nextWatcherID;
        watchers[id] = watcher;
        watcher.id = id;
        watcher.on("change", function (event, filename, stat, files) {
            remote.onChange && remote.onChange(id, event, filename, stat, files);
        });
        var token = {id: id};
        return token;
    }

    // Remote side writing to our local writable streams
    function write(id, chunk) {
        // They want to write to our real stream
        var stream = streams[id];
        if (!stream) return;
        stream.write(chunk);
    }
    function destroy(id) {
        var stream = streams[id];
        if (!stream) return;
        delete streams[id];

        if (!stream.destroy) {
            // Ignore; e.g. memory streams don't usually have this
        }
        else if (typeof stream.destroy != "function") {
            console.trace("##### WEIRD STREAM: ", stream, typeof stream.destroy, typeof stream.close);
        }
        else {
            stream.destroy();
        }
    }
    function end(id, chunk) {
        var stream = streams[id];
        if (!stream) return;
        delete streams[id];
        if (chunk) stream.end(chunk);
        else stream.end();
    }
    function resume(id) {
        var stream = streams[id];
        if (!stream) return;
        stream.resume && stream.resume();
    }
    function pause(id) {
        var stream = streams[id];
        if (!stream) return;
        stream.pause && stream.pause();
    }

    function kill(pid, code) {
        var process = processes[pid];
        if (!process) return;
        process.kill(code);
    }

    function unref(pid) {
        var process = processes[pid];
        if (!process) return;
        process.unref();
        process.unreffed = true;
    }

    function resize(pid, cols, rows) {
        var process = processes[pid];
        if (!process) return;

        // Resize can throw
        try { process.resize(cols, rows); }
        catch(e) {}
    }

    function closeWatcher(id) {
        var watcher = watchers[id];
        if (!watcher) return;
        delete watchers[id];
        watcher.close();
    }

    /**
     * Add additional timing info to any "ping" call.
     */
    function wrapPingCall(name, fnName, args) {
        if (name === "ping" && fnName === "ping" && args[0] === "serverTime" && args.length === 2) {
            var start = Date.now();
            var callback = args[1];

            args[1] = function(err, payload) {
                if (err) return callback(err);
                callback(null, {
                    serverTime: Date.now() - start
                });
            };
        }
    }

    function call(name, fnName, args) {
        return apiHandler.callStoredApiFunction(name, fnName, args);
    }

    function onData(id, chunk) {
        var stream = proxyStreams[id];
        if (!stream) return;
        stream.emit("data", chunk);
    }
    function onEnd(id, chunk) {
        var stream = proxyStreams[id];
        if (!stream) return;
        // TODO: not delete proxy if close is going to be called later.
        // but somehow do delete proxy if close won't be called later.
        delete proxyStreams[id];
        stream.emit("end", chunk);
    }
    function onClose(id) {
        var stream = proxyStreams[id];
        if (!stream) return;
        delete proxyStreams[id];
        stream.emit("close");
    }

    // Can be used for keepalive checks.
    function ping(callback) {
        if (typeof callback !== "function") {
            return console.error(
                "[WORKER] [PING] Callback passed is not a function. Callback is: ",
                callback
            );
        }
        callback();
    }

    function processCallback(err, meta, callback) {
        // Make error objects serializable
        var nerr;
        if (err) {
            nerr = {
                stack: process.pid + ": " + err.stack
            };
            if (err.hasOwnProperty("code")) nerr.code = err.code;
            if (err.hasOwnProperty("message")) nerr.message = err.message;
            if (err.hasOwnProperty("stdout")) nerr.stdout = err.stdout;
            if (err.hasOwnProperty("stderr")) nerr.stderr = err.stderr;
            if (!meta)
                return callback(nerr);
        }
        var token = Array.isArray(meta) ? [] : {};
        var keys = Object.keys(meta || {});
        for (var i = 0, l = keys.length; i < l; i++) {
            var key = keys[i];
            if (meta[key] == undefined) {
                token[key] = undefined;
                continue;
            }
            switch (key) {
                case "stream": token.stream = storeStream(meta.stream); break;
                case "process": token.process = storeProcess(meta.process); break;
                case "pty": token.pty = storePty(meta.pty); break;
                case "watcher": token.watcher = storeWatcher(meta.watcher); break;
                case "api": token.api = apiHandler.storeApi(meta.api); break;
                default: token[key] = meta[key]; break;
            }
        }
        // Call the remote callback with the result
        callback(nerr, token);
    }

    function route(name) {
        return function wrapped(path, options, callback) {
            if (typeof callback !== "function") {
                console.error(name + ": callback must be function", path, options);
                return;
            }
            // Call the real local function, but intercept the callback
            if (options.stream) {
                options.stream = makeStreamProxy(options.stream);
            }
            // TODO: client can kill server by sending path=null !
            var err;
            if (path === null || path === undefined) {
                console.error(
                    "Refusing to process invalid request for name: ",
                    name,
                    " and params: ",
                    path,
                    options
                );
                err = new Error("Refusing to process invalid request: missing path");
                err.code = "EINVALIDPATH";
                return callback(err);
            }

            // Ticket: https://t.corp.amazon.com/AWS-Cloud9-8919
            // It appears that the options may be a string at times, causing
            // a crash down the line
            if (!options || typeof options !== "object") {
                console.error(
                    "Refusing to process invalid request for name: ",
                    name,
                    " and params: ",
                    path,
                    options
                );
                err = new Error(
                    "Refusing to process invalid request: empty or invalid options object"
                );
                err.code = "EINVALIDOPTIONS";
                return callback(err);
            }
            if (options.api) {
                options.api = apiHandler.makeApiProxy(options.api);
            }

            vfs[name](path, options, function (err, meta) {
                processCallback(err, meta, callback);
            });
        };
    }
}
inherits(Worker, Agent);

});


define('@c9/smith', function (module, exports, require) {

/* eslint-env browser */

/*
Copyright (c) 2012 Ajax.org B.V

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

"use strict";

var streamTransport = require("./src/stream-transport");
var AbstractTransport = require("./src/abstract-transport").AbstractTransport;
var agent = require("./src/agent");

var exports = module.exports;

exports.Agent = agent.Agent;
exports.AbstractTransport = AbstractTransport;
exports.Transport = streamTransport.Transport;
exports.StreamTransport = streamTransport.Transport;
exports.deFramer = streamTransport.deFramer;
exports.liven = agent.liven;
exports.freeze = agent.freeze;
exports.getType = agent.getType;

exports.inherits = require("./src/inherits").inherits;
exports.msgpack = require("@c9/msgpack-js");
exports.WebSocketTransport = require("./src/websocket-transport").WebSocketTransport;
exports.BrowserTransport = require("./src/browser-transport").BrowserTransport;
exports.EngineIoTransport = require("./src/engineio-transport").EngineIoTransport;

});


define('@c9/smith/src/stream-transport', function (module, exports, require) {

"use strict";

var msgpack = require("@c9/msgpack-js");
var inherits = require("./inherits").inherits;
var AbstractTransport = require("./abstract-transport").AbstractTransport;

exports.Transport = StreamTransport;
exports.StreamTransport = StreamTransport;
exports.deFramer = deFramer;

////////////////////////////////////////////////////////////////////////////////

// Transport is a connection between two Agents.  It lives on top of a duplex,
// binary stream.
// @input - the stream we listen for data on
// @output - the stream we write to (can be the same object as input)
// @send(message) - send a message to the other side
// "message" - event emitted when we get a message from the other side.
// "disconnect" - the transport was disconnected
// "error" - event emitted for stream error or disconnect
// "drain" - drain event from output stream

function StreamTransport(input) {
    var self = this;
    var output;
    if (Array.isArray(input)) {
        output = input[1];
        input = input[0];
    } else {
        output = input;
    }
    this.input = input;
    this.output = output;

    if (!input.readable) throw new Error("Input is not readable");
    if (!output.writable) throw new Error("Output is not writable");

    // We should always have someone listening, or when an error is emittied
    // it may not be caught.  This way others can listen as well though.
    self.on("error", transportError);

    // Attach event listeners
    input.on("data", onData);
    input.on("end", onDisconnect);
    input.on("timeout", onDisconnect);
    input.on("close", onDisconnect);
    input.on("error", onError);
    output.on("drain", onDrain);
    if (output !== input) {
        output.on("end", onDisconnect);
        output.on("timeout", onDisconnect);
        output.on("close", onDisconnect);
        output.on("error", onError);
    }

    var parse = deFramer(function(err, frame) {
        if (err) return self.emit("error", err);

        var message;
        try {
            message = msgpack.decode(frame);
        } catch (err) {
            return self.emit("error", err);
        }

        exports.debug &&
            console.log(process.pid + " <- " + require("util").inspect(message, false, 2, true));
        self.emit("message", message);
    });

    function transportError(err) {
        console.error("ERROR in transport", err);
    }

    // Route data chunks to the parser, but check for errors
    function onData(chunk) {
        parse(chunk);
    }

    // Forward drain events from the writable stream
    function onDrain() {
        self.emit("drain");
    }
    // Forward all error events to the transport
    function onError(err) {
        self.emit("error", err);
    }
    function onDisconnect() {
        // Remove all the listeners we added and destroy the streams
        exports.debug && console.log("Smith: Transport Disconnect");
        input.removeListener("data", onData);
        input.removeListener("end", onDisconnect);
        input.removeListener("timeout", onDisconnect);
        input.removeListener("close", onDisconnect);
        output.removeListener("drain", onDrain);
        if (input.destroy) input.destroy();
        if (input !== output) {
            output.removeListener("end", onDisconnect);
            output.removeListener("timeout", onDisconnect);
            output.removeListener("close", onDisconnect);
            if (output.destroy && output !== process.stdout) output.destroy();
        }
        self.emit("disconnect");
    }
    this.disconnect = onDisconnect;
}
inherits(StreamTransport, AbstractTransport);

StreamTransport.prototype.send = function(message) {
    // Uncomment to debug protocol
    exports.debug &&
        console.log(process.pid + " -> " + require("util").inspect(message, false, 2, true));

    // Serialize the messsage.
    var frame = msgpack.encode(message);

    // Send a 4 byte length header before the frame.
    var header = new Buffer(10);
    header.writeUInt32BE(frame.length, 0);

    // Compute 4 byte jenkins hash
    var a = frame.length >> 24;
    var b = (frame.length >> 16) & 0xff;
    var c = (frame.length >> 8) & 0xff;
    var d = frame.length & 0xff;

    // Little bit inlined, but fast
    var hash = 0;
    hash += a;
    hash += hash << 10;
    hash += hash >> 6;
    hash += b;
    hash += hash << 10;
    hash += hash >> 6;
    hash += c;
    hash += hash << 10;
    hash += hash >> 6;
    hash += d;
    hash += hash << 10;
    hash += hash >> 6;

    // Shuffle bits
    hash += hash << 3;
    hash = hash ^ (hash >> 11);
    hash += hash << 15;
    hash |= 0;
    header.writeInt32BE(hash, 4, true);

    // 2 Reserved bytes for future usage
    header.writeUInt16BE(0, 8);

    this.output.write(header);

    // Send the serialized message.
    return this.output.write(frame);
};

// A simple state machine that consumes raw bytes and emits frame events.
// Returns a parser function that consumes buffers.  It emits message buffers
// via onMessage callback passed in.
function deFramer(onFrame) {
    var buffer;
    var state = 0;
    var length = 0;
    var expected_hash = 0;
    var hash = 0;
    var offset;

    return function parse(chunk) {
        for (var i = 0, l = chunk.length; i < l; i++) {
            switch (state) {
                case 0:
                    length |= chunk[i] << 24;
                    expected_hash = 0;
                    state = 1;
                    break;
                case 1:
                    length |= chunk[i] << 16;
                    state = 2;
                    break;
                case 2:
                    length |= chunk[i] << 8;
                    state = 3;
                    break;
                case 3:
                    length |= chunk[i];
                    expected_hash += chunk[i];
                    expected_hash += expected_hash << 10;
                    expected_hash += expected_hash >> 6;

                    // Shuffle bits
                    expected_hash += expected_hash << 3;
                    expected_hash = expected_hash ^ (expected_hash >> 11);
                    expected_hash += expected_hash << 15;
                    expected_hash |= 0;

                    hash = 0;
                    state = 4;
                    break;
                case 4:
                    hash |= chunk[i] << 24;
                    state = 5;
                    break;
                case 5:
                    hash |= chunk[i] << 16;
                    state = 6;
                    break;
                case 6:
                    hash |= chunk[i] << 8;
                    state = 7;
                    break;
                case 7:
                    hash |= chunk[i];
                    state = 8;
                    if (hash !== expected_hash) {
                        // Resetting state to be able to process all chunk that comes after.
                        state = 0;
                        offset = 0;
                        console.log("Worker stdout received:" + chunk);

                        // This means that something has been written directly to process stdout.
                        return onFrame(
                            new Error(
                                "Hash mismatch, expected: " +
                                    expected_hash.toString(16) +
                                    " got: " +
                                    hash.toString(16) +
                                    ", length: " +
                                    length +
                                    ", chunk length: " +
                                    chunk.length +
                                    // Show only INSPECT_MAX_BYTES (default: 50) because chunk can be arbitrarily large.
                                    ", chunk: " +
                                    chunk.inspect()
                            )
                        );
                    }

                    if (length > 100 * 1024 * 1024) {
                        return onFrame(
                            new Error(
                                "Too big buffer " +
                                    length +
                                    // Show only INSPECT_MAX_BYTES (default: 50) because chunk can be arbitrarily large.
                                    ", chunk: " +
                                    chunk.inspect()
                            )
                        );
                    }

                    buffer = new Buffer(length);
                    offset = 0;
                    state = 9;
                    break;
                // Two reserved bytes
                case 9:
                    state = 10;
                    break;
                case 10:
                    state = 11;
                    break;

                // Data itself
                case 11:
                    var len = l - i;
                    var emit = false;
                    if (len + offset >= length) {
                        emit = true;
                        len = length - offset;
                    }
                    // TODO: optimize for case where a copy isn't needed can a slice can
                    // be used instead?
                    chunk.copy(buffer, offset, i, i + len);
                    offset += len;
                    i += len - 1;
                    if (emit) {
                        onFrame(null, buffer);
                        state = 0;
                        length = 0;
                        buffer = undefined;
                        offset = undefined;
                    }
                    break;
                default:
                // fall through
            }

            // Common case
            if (state <= 3 && !emit) {
                expected_hash += chunk[i];
                expected_hash += expected_hash << 10;
                expected_hash += expected_hash >> 6;
            }

            emit = false;
        }
    };
}

});


define('@c9/msgpack-js', function (module, exports, require) {

exports.encode = function (value) {
  var buffer = new Buffer(sizeof(value));
  encode(value, buffer, 0);
  return buffer;
};

exports.decode = decode;

// http://wiki.msgpack.org/display/MSGPACK/Format+specification
// I've extended the protocol to have two new types that were previously reserved.
//   buffer 16  11011000  0xd8
//   buffer 32  11011001  0xd9
// These work just like raw16 and raw32 except they are node buffers instead of strings.
//
// Also I've added a type for `undefined`
//   undefined  11000100  0xc4

function Decoder(buffer, offset) {
  this.offset = offset || 0;
  this.buffer = buffer;
}
Decoder.prototype.map = function (length) {
  var value = {};
  for (var i = 0; i < length; i++) {
    var key = this.parse();
    value[key] = this.parse();
  }
  return value;
};
Decoder.prototype.buf = function (length) {
  var value = this.buffer.slice(this.offset, this.offset + length);
  this.offset += length;
  return value;
};
Decoder.prototype.raw = function (length) {
  var value = this.buffer.toString('utf8', this.offset, this.offset + length);
  this.offset += length;
  return value;
};
Decoder.prototype.array = function (length) {
  var value = new Array(length);
  for (var i = 0; i < length; i++) {
    value[i] = this.parse();
  }
  return value;
};
Decoder.prototype.parse = function () {
  var type = this.buffer[this.offset];
  var value, length;
  // FixRaw
  if ((type & 0xe0) === 0xa0) {
    length = type & 0x1f;
    this.offset++;
    return this.raw(length);
  }
  // FixMap
  if ((type & 0xf0) === 0x80) {
    length = type & 0x0f;
    this.offset++;
    return this.map(length);
  }
  // FixArray
  if ((type & 0xf0) === 0x90) {
    length = type & 0x0f;
    this.offset++;
    return this.array(length);
  }
  // Positive FixNum
  if ((type & 0x80) === 0x00) {
    this.offset++;
    return type;
  }
  // Negative Fixnum
  if ((type & 0xe0) === 0xe0) {
    value = this.buffer.readInt8(this.offset);
    this.offset++;
    return value;
  }
  switch (type) {
  // raw 16
  case 0xda:
    length = this.buffer.readUInt16BE(this.offset + 1);
    this.offset += 3;
    return this.raw(length);
  // raw 32
  case 0xdb:
    length = this.buffer.readUInt32BE(this.offset + 1);
    this.offset += 5;
    return this.raw(length);
  // nil
  case 0xc0:
    this.offset++;
    return null;
  // false
  case 0xc2:
    this.offset++;
    return false;
  // true
  case 0xc3:
    this.offset++;
    return true;
  // undefined
  case 0xc4:
    this.offset++;
    return undefined;
  // uint8
  case 0xcc:
    value = this.buffer[this.offset + 1];
    this.offset += 2;
    return value;
  // uint 16
  case 0xcd:
    value = this.buffer.readUInt16BE(this.offset + 1);
    this.offset += 3;
    return value;
  // uint 32
  case 0xce:
    value = this.buffer.readUInt32BE(this.offset + 1);
    this.offset += 5;
    return value;
  // uint64
  case 0xcf:
    value = this.buffer.readUInt64BE(this.offset + 1);
    this.offset += 9;
    return value;
  // int 8
  case 0xd0:
    value = this.buffer.readInt8(this.offset + 1);
    this.offset += 2;
    return value;
  // int 16
  case 0xd1:
    value = this.buffer.readInt16BE(this.offset + 1);
    this.offset += 3;
    return value;
  // int 32
  case 0xd2:
    value = this.buffer.readInt32BE(this.offset + 1);
    this.offset += 5;
    return value;
  // int 64
  case 0xd3:
    value = this.buffer.readInt64BE(this.offset + 1);
    this.offset += 9;
    return value;
  // map 16
  case 0xde:
    length = this.buffer.readUInt16BE(this.offset + 1);
    this.offset += 3;
    return this.map(length);
  // map 32
  case 0xdf:
    length = this.buffer.readUInt32BE(this.offset + 1);
    this.offset += 5;
    return this.map(length);
  // array 16
  case 0xdc:
    length = this.buffer.readUInt16BE(this.offset + 1);
    this.offset += 3;
    return this.array(length);
  // array 32
  case 0xdd:
    length = this.buffer.readUInt32BE(this.offset + 1);
    this.offset += 5;
    return this.array(length);
  // buffer 16
  case 0xd8:
    length = this.buffer.readUInt16BE(this.offset + 1);
    this.offset += 3;
    return this.buf(length);
  // buffer 32
  case 0xd9:
    length = this.buffer.readUInt32BE(this.offset + 1);
    this.offset += 5;
    return this.buf(length);
  // float
  case 0xca:
    value = this.buffer.readFloatBE(this.offset + 1);
    this.offset += 5;
    return value;
  // double
  case 0xcb:
    value = this.buffer.readDoubleBE(this.offset + 1);
    this.offset += 9;
    return value;
  default:
    // none
  }
  throw new Error("Unknown type 0x" + type.toString(16));
};
function decode(buffer) {
  var decoder = new Decoder(buffer);
  var value = decoder.parse();
  if (decoder.offset !== buffer.length) throw new Error((buffer.length - decoder.offset) + " trailing bytes");
  return value;
}

function encode(value, buffer, offset) {
  var type = typeof value;
  var i;
  var length;

  // Strings Bytes
  if (type === "string") {
    length = Buffer.byteLength(value);
    // fix raw
    if (length < 0x20) {
      buffer[offset] = length | 0xa0;
      length && buffer.write(value, offset + 1);
      return 1 + length;
    }
    // raw 16
    if (length < 0x10000) {
      buffer[offset] = 0xda;
      buffer.writeUInt16BE(length, offset + 1);
      buffer.write(value, offset + 3);
      return 3 + length;
    }
    // raw 32
    if (length < 0x100000000) {
      buffer[offset] = 0xdb;
      buffer.writeUInt32BE(length, offset + 1);
      buffer.write(value, offset + 5);
      return 5 + length;
    }
  }

  if (Buffer.isBuffer(value)) {
    length = value.length;
    // buffer 16
    if (length < 0x10000) {
      buffer[offset] = 0xd8;
      buffer.writeUInt16BE(length, offset + 1);
      value.copy(buffer, offset + 3);
      return 3 + length;
    }
    // buffer 32
    if (length < 0x100000000) {
      buffer[offset] = 0xd9;
      buffer.writeUInt32BE(length, offset + 1);
      value.copy(buffer, offset + 5);
      return 5 + length;
    }
  }

  if (type === "number") {
    // Floating Point
    if ((value << 0) !== value) {
      buffer[offset] =  0xcb;
      buffer.writeDoubleBE(value, offset + 1);
      return 9;
    }

    // Integers
    if (value >=0) {
      // positive fixnum
      if (value < 0x80) {
        buffer[offset] = value;
        return 1;
      }
      // uint 8
      if (value < 0x100) {
        buffer[offset] = 0xcc;
        buffer[offset + 1] = value;
        return 2;
      }
      // uint 16
      if (value < 0x10000) {
        buffer[offset] = 0xcd;
        buffer.writeUInt16BE(value, offset + 1);
        return 3;
      }
      // uint 32
      if (value < 0x100000000) {
        buffer[offset] = 0xce;
        buffer.writeUInt32BE(value, offset + 1);
        return 5;
      }
      // uint 64
      if (value < 0x10000000000000000) {
        buffer[offset] = 0xcf;
        buffer.writeUInt64BE(value, offset + 1);
        return 9;
      }
      throw new Error("Number too big 0x" + value.toString(16));
    }
    // negative fixnum
    if (value >= -0x20) {
      buffer.writeInt8(value, offset);
      return 1;
    }
    // int 8
    if (value >= -0x80) {
      buffer[offset] = 0xd0;
      buffer.writeInt8(value, offset + 1);
      return 2;
    }
    // int 16
    if (value >= -0x8000) {
      buffer[offset] = 0xd1;
      buffer.writeInt16BE(value, offset + 1);
      return 3;
    }
    // int 32
    if (value >= -0x80000000) {
      buffer[offset] = 0xd2;
      buffer.writeInt32BE(value, offset + 1);
      return 5;
    }
    // int 64
    if (value >= -0x8000000000000000) {
      buffer[offset] = 0xd3;
      buffer.writeInt64BE(value, offset + 1);
      return 9;
    }
    throw new Error("Number too small -0x" + value.toString(16).substr(1));
  }

  // undefined
  if (type === "undefined") {
    buffer[offset] = 0xc4;
    return 1;
  }

  // null
  if (value === null) {
    buffer[offset] = 0xc0;
    return 1;
  }

  // Boolean
  if (type === "boolean") {
    buffer[offset] = value ? 0xc3 : 0xc2;
    return 1;
  }

  // Container Types
  if (type === "object") {
    length, size = 0;
    var isArray = Array.isArray(value);

    if (isArray) {
      length = value.length;
    }
    else {
      var keys = Object.keys(value);
      length = keys.length;
    }

    var size;
    if (length < 0x10) {
      buffer[offset] = length | (isArray ? 0x90 : 0x80);
      size = 1;
    }
    else if (length < 0x10000) {
      buffer[offset] = isArray ? 0xdc : 0xde;
      buffer.writeUInt16BE(length, offset + 1);
      size = 3;
    }
    else if (length < 0x100000000) {
      buffer[offset] = isArray ? 0xdd : 0xdf;
      buffer.writeUInt32BE(length, offset + 1);
      size = 5;
    }

    if (isArray) {
      for (i = 0; i < length; i++) {
        size += encode(value[i], buffer, offset + size);
      }
    }
    else {
      for (i = 0; i < length; i++) {
        var key = keys[i];
        size += encode(key, buffer, offset + size);
        size += encode(value[key], buffer, offset + size);
      }
    }

    return size;
  }
  throw new Error("Unknown type " + type);
}

function sizeof(value) {
  var type = typeof value;
  var length;
  var i;

  // Raw Bytes
  if (type === "string") {
    length = Buffer.byteLength(value);
    if (length < 0x20) {
      return 1 + length;
    }
    if (length < 0x10000) {
      return 3 + length;
    }
    if (length < 0x100000000) {
      return 5 + length;
    }
  }

  if (Buffer.isBuffer(value)) {
    length = value.length;
    if (length < 0x10000) {
      return 3 + length;
    }
    if (length < 0x100000000) {
      return 5 + length;
    }
  }

  if (type === "number") {
    // Floating Point
    // double
    if (value << 0 !== value) return 9;

    // Integers
    if (value >=0) {
      // positive fixnum
      if (value < 0x80) return 1;
      // uint 8
      if (value < 0x100) return 2;
      // uint 16
      if (value < 0x10000) return 3;
      // uint 32
      if (value < 0x100000000) return 5;
      // uint 64
      if (value < 0x10000000000000000) return 9;
      throw new Error("Number too big 0x" + value.toString(16));
    }
    // negative fixnum
    if (value >= -0x20) return 1;
    // int 8
    if (value >= -0x80) return 2;
    // int 16
    if (value >= -0x8000) return 3;
    // int 32
    if (value >= -0x80000000) return 5;
    // int 64
    if (value >= -0x8000000000000000) return 9;
    throw new Error("Number too small -0x" + value.toString(16).substr(1));
  }

  // Boolean, null, undefined
  if (type === "boolean" || type === "undefined" || value === null) return 1;

  // Container Types
  if (type === "object") {
    var size = 0;
    if (Array.isArray(value)) {
      length = value.length;
      for (i = 0; i < length; i++) {
        size += sizeof(value[i]);
      }
    }
    else {
      var keys = Object.keys(value);
      length = keys.length;
      for (i = 0; i < length; i++) {
        var key = keys[i];
        size += sizeof(key) + sizeof(value[key]);
      }
    }
    if (length < 0x10) {
      return 1 + size;
    }
    if (length < 0x10000) {
      return 3 + size;
    }
    if (length < 0x100000000) {
      return 5 + size;
    }
    throw new Error("Array or object too long 0x" + length.toString(16));
  }
  throw new Error("Unknown type " + type);
}



});


define('@c9/smith/src/inherits', function (module, exports, require) {

exports.inherits = function inherits(Child, Parent) {
    Child.prototype = Object.create(Parent.prototype, {
        constructor: {value: Child},
    });
};

});


define('@c9/smith/src/abstract-transport', function (module, exports, require) {

"use strict";

var inherits = require("./inherits").inherits;
var EventEmitter = require("./events").EventEmitter;

exports.AbstractTransport = AbstractTransport;

////////////////////////////////////////////////////////////////////////////////

// Transport is a connection between two Agents.
//
// @send(message) - send a message to the other side
// "message" - event emitted when we get a message from the other side.
// "disconnect" - the transport was disconnected
// "error" - event emitted for stream error or disconnect
// "drain" - drain event from output stream

function AbstractTransport() {}
inherits(AbstractTransport, EventEmitter);

AbstractTransport.prototype.send = function(message) {
    throw new Error("abstract method!");
};

AbstractTransport.prototype.disconnect = function() {};

});


define('@c9/smith/src/events', function (module, exports, require) {

// @see https://github.com/ryanramage/events/blob/c22287485580ba9f182a102f8c5427bcf962f73e/events.js

/**
 * ## Events module
 *
 * This is a browser port of the node.js events module. Many objects and
 * modules emit events and these are instances of events.EventEmitter.
 *
 * You can access this module by doing: `require("events")`
 *
 * Functions can then be attached to objects, to be executed when an event is
 * emitted. These functions are called listeners.
 *
 * @module
 */

/**
 * To access the EventEmitter class, require('events').EventEmitter.
 *
 * When an EventEmitter instance experiences an error, the typical action is to
 * emit an 'error' event. Error events are treated as a special case. If there
 * is no listener for it, then the default action is for the error to throw.
 *
 * All EventEmitters emit the event 'newListener' when new listeners are added.
 *
 * @name events.EventEmitter
 * @api public
 *
 * ```javascript
 * var EventEmitter = require('events').EventEmitter;
 *
 * // create an event emitter
 * var emitter = new EventEmitter();
 * ```
 */

var EventEmitter = (exports.EventEmitter = function() {});

var isArray =
    Array.isArray ||
    function(obj) {
        return toString.call(obj) === "[object Array]";
    };

/**
 * By default EventEmitters will print a warning if more than 10 listeners are
 * added for a particular event. This is a useful default which helps finding
 * memory leaks. Obviously not all Emitters should be limited to 10. This
 * function allows that to be increased. Set to zero for unlimited.
 *
 * @name emitter.setMaxListeners(n)
 * @param {Number} n - The maximum number of listeners
 * @api public
 */

// By default EventEmitters will print a warning if more than
// 10 listeners are added to it. This is a useful default which
// helps finding memory leaks.
//
// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
var defaultMaxListeners = 10;
EventEmitter.prototype.setMaxListeners = function(n) {
    if (!this._events) this._events = {};
    this._events.maxListeners = n;
};

/**
 * Execute each of the listeners in order with the supplied arguments.
 *
 * @name emitter.emit(event, [arg1], [arg2], [...])
 * @param {String} event - The event name/id to fire
 * @api public
 */

EventEmitter.prototype.emit = function(type) {
    // If there is no 'error' event listener then throw.
    if (type === "error") {
        if (
            !this._events ||
            !this._events.error ||
            (isArray(this._events.error) && !this._events.error.length)
        ) {
            if (arguments[1] instanceof Error) {
                throw arguments[1]; // Unhandled 'error' event
            } else {
                throw new Error("Uncaught, unspecified 'error' event.");
            }
        }
    }

    if (!this._events) return false;
    var handler = this._events[type];
    if (!handler) return false;

    if (typeof handler == "function") {
        switch (arguments.length) {
            // fast cases
            case 1:
                handler.call(this);
                break;
            case 2:
                handler.call(this, arguments[1]);
                break;
            case 3:
                handler.call(this, arguments[1], arguments[2]);
                break;
            // slower
            default:
                var args = Array.prototype.slice.call(arguments, 1);
                handler.apply(this, args);
        }
        return true;
    } else if (isArray(handler)) {
        args = Array.prototype.slice.call(arguments, 1);

        var listeners = handler.slice();
        for (var i = 0, l = listeners.length; i < l; i++) {
            listeners[i].apply(this, args);
        }
        return true;
    } else {
        return false;
    }
};

/**
 * Adds a listener to the end of the listeners array for the specified event.
 *
 * @name emitter.on(event, listener) | emitter.addListener(event, listener)
 * @param {String} event - The event name/id to listen for
 * @param {Function} listener - The function to bind to the event
 * @api public
 *
 * ```javascript
 * session.on('change', function (userCtx) {
 *     console.log('session changed!');
 * });
 * ```
 */

// EventEmitter is defined in src/node_events.cc
// EventEmitter.prototype.emit() is also defined there.
EventEmitter.prototype.addListener = function(type, listener) {
    if ("function" !== typeof listener) {
        throw new Error("addListener only takes instances of Function");
    }

    if (!this._events) this._events = {};

    // To avoid recursion in the case that type == "newListeners"! Before
    // adding it to the listeners, first emit "newListeners".
    this.emit("newListener", type, listener);

    if (!this._events[type]) {
        // Optimize the case of one listener. Don't need the extra array object.
        this._events[type] = listener;
    } else if (isArray(this._events[type])) {
        // Check for listener leak
        if (!this._events[type].warned) {
            var m;
            if (this._events.maxListeners !== undefined) {
                m = this._events.maxListeners;
            } else {
                m = defaultMaxListeners;
            }

            if (m && m > 0 && this._events[type].length > m) {
                this._events[type].warned = true;
                console.error(
                    "(node) warning: possible EventEmitter memory " +
                        "leak detected. %d listeners added. " +
                        "Use emitter.setMaxListeners() to increase limit.",
                    this._events[type].length
                );
                console.trace();
            }
        }

        // If we've already got an array, just append.
        this._events[type].push(listener);
    } else {
        // Adding the second element, need to change to array.
        this._events[type] = [this._events[type], listener];
    }

    return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

/**
 * Adds a one time listener for the event. This listener is invoked only the
 * next time the event is fired, after which it is removed.
 *
 * @name emitter.once(event, listener)
 * @param {String} event- The event name/id to listen for
 * @param {Function} listener - The function to bind to the event
 * @api public
 *
 * ```javascript
 * db.once('unauthorized', function (req) {
 *     // this event listener will fire once, then be unbound
 * });
 * ```
 */

EventEmitter.prototype.once = function(type, listener) {
    var self = this;
    self.on(type, function g() {
        self.removeListener(type, g);
        listener.apply(this, arguments);
    });

    return this;
};

/**
 * Remove a listener from the listener array for the specified event. Caution:
 * changes array indices in the listener array behind the listener.
 *
 * @name emitter.removeListener(event, listener)
 * @param {String} event - The event name/id to remove the listener from
 * @param {Function} listener - The listener function to remove
 * @api public
 *
 * ```javascript
 * var callback = function (init) {
 *     console.log('duality app loaded');
 * };
 * devents.on('init', callback);
 * // ...
 * devents.removeListener('init', callback);
 * ```
 */

EventEmitter.prototype.removeListener = function(type, listener) {
    if ("function" !== typeof listener) {
        throw new Error("removeListener only takes instances of Function");
    }

    // does not use listeners(), so no side effect of creating _events[type]
    if (!this._events || !this._events[type]) return this;

    var list = this._events[type];

    if (isArray(list)) {
        var i = list.indexOf(listener);
        if (i < 0) return this;
        list.splice(i, 1);
        if (list.length == 0) delete this._events[type];
    } else if (this._events[type] === listener) {
        delete this._events[type];
    }

    return this;
};

/**
 * Removes all listeners, or those of the specified event.
 *
 * @name emitter.removeAllListeners([event])
 * @param {String} event - Event name/id to remove all listeners for (optional)
 * @api public
 */

EventEmitter.prototype.removeAllListeners = function(type) {
    // does not use listeners(), so no side effect of creating _events[type]
    if (type && this._events && this._events[type]) this._events[type] = null;
    return this;
};

/**
 * Returns an array of listeners for the specified event. This array can be
 * manipulated, e.g. to remove listeners.
 *
 * @name emitter.listeners(event)
 * @param {String} events - The event name/id to return listeners for
 * @api public
 *
 * ```javascript
 * session.on('change', function (stream) {
 *     console.log('session changed');
 * });
 * console.log(util.inspect(session.listeners('change'))); // [ [Function] ]
 * ```
 */

EventEmitter.prototype.listeners = function(type) {
    if (!this._events) this._events = {};
    if (!this._events[type]) this._events[type] = [];
    if (!isArray(this._events[type])) {
        this._events[type] = [this._events[type]];
    }
    return this._events[type];
};

/**
 * @name emitter Event: 'newListener'
 *
 * This event is emitted any time someone adds a new listener.
 *
 * ```javascript
 * emitter.on('newListener', function (event, listener) {
 *     // new listener added
 * });
 * ```
 */

});


define('@c9/smith/src/agent', function (module, exports, require) {

var EventEmitter = require("./events").EventEmitter;
var inherits = require("./inherits").inherits;
var AbstractTransport = require("./abstract-transport").AbstractTransport;
var TOTAL_KEYS = Math.pow(2, 32); //Due to the use of >> when incrementing ids.
exports.Agent = Agent;
exports.liven = liven;
exports.freeze = freeze;
exports.getType = getType;

////////////////////////////////////////////////////////////////////////////////
// Agent is an API serving node in the architect-agent rpc mesh.  It contains
// a table of functions that actually do the work and serve them to a Agent
// agent.  An agent can connect to one other agent at a time.
function Agent(api, options) {
    if (!this instanceof Agent) throw new Error("Forgot to use new with Agent constructor");

    options = options || {};
    this.withPromises = !!options.withPromises;

    this.api = api || {};
    var keys = Object.keys(this.api);
    for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        this.api[key] = callbackify(this.withPromises, this.api[key]);
    }

    // Bind event handlers and callbacks
    this.disconnect = this.disconnect.bind(this);
    this._onMessage = this._onMessage.bind(this);
    this._onDrain = this._onDrain.bind(this);
    this._onReady = this._onReady.bind(this);
    this._getFunction = this._getFunction.bind(this);
    this._storeFunction = this._storeFunction.bind(this);

    this.remoteApi = {}; // Persist the API object between connections
    this.transport = undefined;
    this.callbacks = undefined;
    this.nextKey = 1;
    this.firstKey = undefined;
    this.keysLeft = undefined; // The amount of keys left that have never been used since connecting.
}
inherits(Agent, EventEmitter);

// Time to wait for Agent connections to finish
Agent.prototype.connectionTimeout = 10000;

Agent.prototype.connect = promisify(false, function connect(transport, callback) {
    if (!(transport instanceof AbstractTransport)) {
        throw new Error(
            "not a transport. If you passed in a stream then use 'new StreamTransport(stream)' instead"
        );
    }

    this.transport = transport;
    this.callbacks = {};
    this.firstKey = this.nextKey;
    this.keysLeft = TOTAL_KEYS;

    transport.on("error", this.disconnect);
    transport.on("disconnect", this.disconnect);
    transport.on("message", this._onMessage);
    transport.on("drain", this._onDrain);

    // Handshake with the other end
    this.send(["ready", this._onReady]);

    // Start timeout and route events to callback
    this.on("connect", onConnect);
    this.on("disconnect", onDisconnect);
    this.on("error", onError);
    var timeout;
    if (this.connectionTimeout) {
        timeout = setTimeout(onTimeout, this.connectionTimeout);
    }

    var self = this;
    function onConnect(api) {
        reset();
        done(null, api);
    }
    function onDisconnect(err) {
        console.log("Smith: Agent Disconnect");
        onError(err || new Error("EDISCONNECT: Agent disconnected"));
    }
    function onError(err) {
        reset();
        done(err);
    }
    function onTimeout() {
        reset();
        var err = new Error("ETIMEDOUT: Timeout while waiting for Agent agent to connect.");
        err.code = "ETIMEDOUT";
        self.emit("error", err);
    }
    // Only one event should happen, so stop event listeners on first event.
    function reset() {
        self.removeListener("connect", onConnect);
        self.removeListener("disconnect", onDisconnect);
        self.removeListener("error", onError);
        clearTimeout(timeout);
    }

    function done(err, api) {
        if (!callback) {
            if (err) {
                self.emit("error", err);
            }
            return;
        }
        callback(err, api);
        callback = null;
    }
});

Agent.prototype.send = function(message) {
    message = freeze(message, this._storeFunction);
    if (!this.transport) {
        return false;
    }

    try {
        if (!this.transport.send(message)) {
            this.emit("buffering");
        }
    } catch (e) {
        console.error("Smith: Agent could not send message: ", e.stack, e.message);
        return false;
    }
    return true;
};

Agent.prototype._onReady = function onReady(names, env) {
    if (!Array.isArray(names)) return;
    var self = this;
    names.forEach(function(name) {
        // Ignore already set functions so that existing function references
        // stay valid.
        if (self.remoteApi.hasOwnProperty(name)) return;
        self.remoteApi[name] = promisify(self.withPromises, function() {
            // When disconnected we can't forward the call.
            if (!self.transport) {
                var callback = arguments[arguments.length - 1];
                if (typeof callback === "function") {
                    setTimeout(function() {
                        var err = new Error("ENOTCONNECTED: Agent is offline, try again later");
                        err.code = "ENOTCONNECTED";
                        callback(err);
                    }, 10);
                }
                return;
            }
            var args = [name];
            args.push.apply(args, arguments);
            self.send(args);
        });
    });
    this.remoteEnv = env;
    this._emitConnect();
};

Agent.prototype._emitConnect = function() {
    this.emit("connect", this.remoteApi);
};

// Disconnect resets the state of the Agent, flushes callbacks and emits a
// "disconnect" event with optional error object.
Agent.prototype.disconnect = function(err) {
    if (!this.transport) {
        console.log("Smith: Agent requested disconnect when already disconnected");
        // Agent is already disconnected
        return;
    }

    var cerr = err;
    if (!cerr) {
        cerr = new Error("EDISCONNECT: Agent disconnected");
        cerr.code = "EDISCONNECT";
        cerr.statusCode = 499;
    }

    // Flush any callbacks
    if (this.callbacks) {
        var callbacks = this.callbacks;
        this.callbacks = undefined;
        var hashError = cerr.message.includes("Hash mismatch");
        forEach(callbacks, function(callback) {
            if (hashError) {
                var original = callback;
                while (original.original) original = original.original;
                console.log("Passing hash error to callback: " + original.toString());
            }
        });
    }

    // Disconnect from transport
    if (this.transport) {
        this.transport.removeListener("error", this.disconnect);
        this.transport.removeListener("disconnect", this.disconnect);
        this.transport.removeListener("message", this._onMessage);
        this.transport.removeListener("drain", this._onDrain);
        this.transport.disconnect();
        this.transport = undefined;
    }

    this.emit("disconnect", err);
};

// Forward drain events
Agent.prototype._onDrain = function() {
    this.emit("drain");
};

// Route incoming messages to the right functions
Agent.prototype._onMessage = function(message) {
    if (!(Array.isArray(message) && message.length)) {
        return this.emit("error", new Error("Message should be an array"));
    }

    message = liven(message, this._getFunction);
    var id = message[0];

    var fn;
    if (id === "ready") {
        var keys = Object.keys(this.api);
        var env = this.api.env;
        fn = function(callback) {
            callback(keys, env);
        };
    } else {
        var fnSource = typeof id === "string" ? this.api : this.callbacks;
        if (!fnSource) {
            console.log(
                "Smith: [Inconsistent State] onMessage handler invoked while transport is disconnected"
            );
            return;
        }
        fn = fnSource[id];

        if (!fn) {
            var keysUsed = TOTAL_KEYS - this.keysLeft;
            var lastKey = this.firstKey + keysUsed;
            var idFromDisconnect = !isBetweenClockwise(this.firstKey, id, lastKey, TOTAL_KEYS);
            if (idFromDisconnect) {
                console.log(
                    "Smith received a message whose callback was already called by a disconnect."
                );
                return;
            } else {
                console.error("Smith: [Inconsistent State] MISSING ID", id);
            }
        }
    }
    if (typeof fn !== "function") {
        return this.emit("error", new Error("Should be function"));
    }
    fn.apply(this, message.slice(1));
};

//Given the numbers start, value and end laying on a cirle,
//checks whether value is clockwise between start and end.
//The circumference of the circle must be passed as well.
function isBetweenClockwise(start, value, end, circumference) {
    if (end < start) end += circumference;
    if (value < start) value += circumference;

    return value < end;
}

// Create a proxy function that calls fn key on the Agent side.
// This is for when a Agent passes a callback to a local function.
Agent.prototype._getFunction = function(key) {
    // var transport = this.transport;
    var _self = this;
    return function() {
        // Call a Agent function using [key, args...]
        var args = [key];
        // Push is actually fast http://jsperf.com/array-push-vs-concat-vs-unshift
        args.push.apply(args, arguments);
        return _self.send(args);
    };
};

// This is for when we call a Agent function and pass in a callback
Agent.prototype._storeFunction = function(fn) {
    if (!this.callbacks) return new Error("Agent disconnected");

    var key = this.nextKey;
    while (this.callbacks.hasOwnProperty(key)) {
        key = (key + 1) >> 0;
        if (key === this.nextKey) {
            throw new Error("Ran out of keys!!");
        }
    }
    this.nextKey = (key + 1) >> 0;
    if (this.keysLeft) {
        this.keysLeft--;
    }

    var callbacks = this.callbacks;
    // Wrap in a self cleaning function and store in the index
    callbacks[key] = function() {
        delete callbacks[key];
        return fn.apply(this, arguments);
    };
    callbacks[key].original = fn;
    return key;
};

// Convert a js object into a serializable object when functions are
// encountered, the storeFunction callback is called for each one.
// storeFunction takes in a function and returns a unique id number. Cycles
// are stored as object with a single $ key and an array of strigs as the
// path. Functions are stored as objects with a single $ key and id as value.
// props. properties starting with "$" have an extra $ prepended.
function freeze(value, storeFunction) {
    var seen = [];
    var paths = [];
    function find(value, path) {
        // find the type of the value
        var type = getType(value);
        // pass primitives through as-is
        if (type !== "function" && type !== "object" && type !== "array" && type !== "date") {
            return value;
        }

        // Look for duplicates
        var index = seen.indexOf(value);
        if (index >= 0) {
            return {$: paths[index]};
        }
        // If not seen, put it in the registry
        index = seen.length;
        seen[index] = value;
        paths[index] = path;

        var o;
        // Look for functions
        if (type === "function") {
            o = storeFunction(value);
        }

        if (type === "date") {
            o = {d: value.getTime()};
        }

        if (o) return {$: o};

        // Recurse on objects and arrays
        return map(
            value,
            function(sub, key) {
                return find(sub, path.concat([key]));
            },
            null,
            function(key) {
                return key[0] === "$" ? "$" + key : key;
            }
        );
    }
    return find(value, []);
}

// Converts flat objects into live objects.  Cycles are re-connected and
// functions are inserted. The getFunction callback is called whenever a
// frozen function is encountered. It expects an ID and returns the function
function liven(message, getFunction) {
    function find(value, parent, key) {
        // find the type of the value
        var type = getType(value);

        // Unescape $$+ escaped keys
        if (key[0] === "$") key = key.substr(1);

        // pass primitives through as-is
        if (type !== "function" && type !== "object" && type !== "array") {
            parent[key] = value;
            return value;
        }

        // Load Specials
        if (value.hasOwnProperty("$")) {
            var special = value.$;
            // Load backreferences
            if (Array.isArray(special)) {
                parent[key] = get(obj.root, special);
                return parent[key];
            }
            if (typeof special === "object") {
                parent[key] = new Date(special.d);
                return parent[key];
            }
            // Load functions
            parent[key] = getFunction(special);
            return parent[key];
        }

        // Recurse on objects and arrays
        var o = Array.isArray(value) ? [] : {};
        parent[key] = o;
        forEach(value, function(sub, key) {
            find(sub, o, key);
        });
        return obj;
    }
    var obj = {};
    find(message, obj, "root");
    return obj.root;
}

////////////////////////////////////////////////////////////////////////////////

// Typeof is broken in javascript, add support for null and buffer types
function getType(value) {
    if (value === null) {
        return "null";
    }
    if (Array.isArray(value)) {
        return "array";
    }
    if (typeof Buffer !== "undefined" && Buffer.isBuffer(value)) {
        return "buffer";
    }
    // TODO: find a way to work with Date instances from other contexts.
    if (value instanceof Date) {
        return "date";
    }
    return typeof value;
}

// Traverse an object to get a value at a path
function get(root, path) {
    var target = root;
    for (var i = 0, l = path.length; i < l; i++) {
        target = target[path[i]];
    }
    return target;
}

// forEach that works on both arrays and objects
function forEach(value, callback, thisp) {
    if (typeof value.forEach === "function") {
        return value.forEach.call(value, callback, thisp);
    }
    var keys = Object.keys(value);
    for (var i = 0, l = keys.length; i < l; i++) {
        var key = keys[i];
        callback.call(thisp, value[key], key, value);
    }
}

// map that works on both arrays and objects
function map(value, callback, thisp, keyMap) {
    if (typeof value.map === "function") {
        return value.map.call(value, callback, thisp);
    }
    var obj = {};
    var keys = Object.keys(value);
    for (var i = 0, l = keys.length; i < l; i++) {
        var key = keys[i];
        obj[keyMap ? keyMap(key) : key] = callback.call(thisp, value[key], key, value);
    }
    return obj;
}

exports.deprecationWarning = function(message, fn) {
    console.trace("DEPRECATED: " + message, fn.toString());
};

// checks if the passed in function follows the node.js callback pattern
function ensureCallbackStyle(fn) {
    return function() {
        var args = Array.prototype.slice.call(arguments);
        var callback = args[args.length - 1];
        var callCount = 0;

        if (typeof callback !== "function") {
            // not alarming on this yet. vfs-sockets does this all over the place
            // exports.deprecationWarning("Remote Smith APIs must be called with a callback.", fn);
        } else {
            var safeCallback = function() {
                if (arguments.length > 2) {
                    exports.deprecationWarning(
                        "Remote Smith APIs may only return one non error value.",
                        fn
                    );
                }
                callCount += 1;
                if (callCount > 1) {
                    exports.deprecationWarning(
                        "Remote Smith APIs must not call callback more than once.",
                        fn
                    );
                } else {
                    callback.apply(this, arguments);
                }
            };
            safeCallback.original = callback;
            args[args.length - 1] = safeCallback;
        }
        var returnValue = fn.apply(this, args);
        if (returnValue) {
            exports.deprecationWarning("Remote Smith APIs must not return any values.", fn);
        }
    };
}

// function is either callback style or returns a promise
// convert that function into node callback style
function callbackify(enabled, fn) {
    if (typeof fn != "function") return fn;
    // if promises are not enabled then only perform checks
    if (!enabled) return ensureCallbackStyle(fn);

    // do nothing if promises are not supported
    if (typeof Promise == "undefined") return fn;

    return function() {
        var args = Array.prototype.slice.call(arguments);
        var callback;
        if (typeof args[args.length - 1] == "function") callback = args.pop();

        var promise = fn.apply(this, args.concat(done));
        if (promise) {
            if (!promise.then) {
                console.trace(
                    "Invalid return value. Expected a promise but got",
                    promise,
                    fn.toString()
                );
                throw new Error("Invalid return value");
            }

            promise
                .then(function(result) {
                    done(null, result);
                })
                .catch(function(err) {
                    done(err);
                });
        }

        var called = false;
        function done(err, result) {
            if (called) return;
            called = true;

            callback && callback(err, result);
        }
    };
}

// converts a function that is callback style and returns a function that
// supports both callbacks and promises
function promisify(enabled, fn) {
    if (typeof fn != "function") return fn;
    if (!enabled) return ensureCallbackStyle(fn);

    // do nothing if promises are not supported
    if (typeof Promise == "undefined") return fn;

    return function() {
        var that = this;

        var args = Array.prototype.slice.call(arguments);
        if (typeof args[args.length - 1] == "function") {
            return fn.apply(that, args);
        } else {
            return new Promise(function(resolve, reject) {
                fn.apply(
                    that,
                    args.concat(function(err, result) {
                        if (err) {
                            reject(err);
                        } else {
                            resolve(result);
                        }
                    })
                );
            });
        }
    };
}

});


define('@c9/smith/src/websocket-transport', function (module, exports, require) {

var msgpack = require("@c9/msgpack-js");
var AbstractTransport = require("./abstract-transport").AbstractTransport;
var inherits = require("./inherits").inherits;

exports.WebSocketTransport = WebSocketTransport;
inherits(WebSocketTransport, AbstractTransport);

exports.debug = false;

// "message" - event emitted when we get a message from the other side.
// "disconnect" - the transport was disconnected
// "error" - event emitted for stream error or disconnect
// "drain" - drain event from output stream
function WebSocketTransport(socket) {
    this.socket = socket;
    var self = this;

    socket.on("message", onMessage);
    socket.on("close", onDisconnect);
    socket.on("error", onError);
    function onError(err) {
        self.emit("error", err);
    }
    function onMessage(data) {
        var message;
        try {
            message = msgpack.decode(data);
        } catch (err) {
            return onError(err);
        }
        exports.debug &&
            console.log(process.pid + " <- " + require("util").inspect(message, false, 2, true));
        self.emit("message", message);
    }
    function onDisconnect() {
        // Remove all the listeners we added and destroy the socket
        console.log("Smith: WebSocketTransport Disconnect");
        socket.removeListener("message", onMessage);
        socket.removeListener("close", onDisconnect);
        self.emit("disconnect");
    }
    this.disconnect = onDisconnect;
    // TODO: Implement "drain" event, pause(), and resume() properly.
    // function onDrain() {
    //   self.emit("drain");
    // }
}

WebSocketTransport.prototype.send = function(message) {
    // Uncomment to debug protocol
    exports.debug &&
        console.log(process.pid + " -> " + require("util").inspect(message, false, 2, true));
    var data;
    try {
        data = msgpack.encode(message);
    } catch (err) {
        return this.emit("error", err);
    }
    this.socket.send(data, {binary: true});
};

});


define('@c9/smith/src/browser-transport', function (module, exports, require) {

var msgpack = require("@c9/msgpack-js");
var AbstractTransport = require("./abstract-transport").AbstractTransport;
var inherits = require("./inherits").inherits;

exports.debug = false;

exports.BrowserTransport = BrowserTransport;
inherits(BrowserTransport, AbstractTransport);

function BrowserTransport(websocket) {
    this.websocket = websocket;
    var self = this;

    websocket.binaryType = "arraybuffer";
    websocket.onmessage = function(evt) {
        var message;
        console.log("length", evt.data.byteLength);
        try {
            message = msgpack.decode(Buffer.from(new Uint8Array(evt.data)));
        } catch (err) {
            return onError(err);
        }
        exports.debug && console.log("<-", message);
        self.emit("message", message);
    };

    websocket.onclose = function(evt) {};

    websocket.onerror = function(evt) {
        onError(new Error(evt.data));
    };

    function onError(err) {
        self.emit("error", err);
    }

    function onDisconnect() {
        console.log("Smith: BrowserTransport Disconnect");
        // Remove all the listeners we added and destroy the socket
        delete websocket.onmessage;
        delete websocket.onclose;
        self.emit("disconnect");
    }
    this.disconnect = onDisconnect;
}

BrowserTransport.prototype.send = function(message) {
    // Uncomment to debug protocol
    exports.debug && console.log("->", message);
    var data;
    try {
        data = msgpack.encode(message);
    } catch (err) {
        return this.emit("error", err);
    }
    this.websocket.send(data);
};

});


define('@c9/smith/src/engineio-transport', function (module, exports, require) {

var AbstractTransport = require("./abstract-transport").AbstractTransport;
var inherits = require("./inherits").inherits;

exports.EngineIoTransport = EngineIoTransport;
inherits(EngineIoTransport, AbstractTransport);
function EngineIoTransport(socket) {
    var self = this;
    this.socket = socket;

    // Route errors from socket to transport.
    function onError(err) {
        self.emit("error", err);
    }

    // Parse and route messages from socket to transport.
    function onMessage(message) {
        if (Array.isArray(message)) {
            if (exports.debug) {
                console.log("<-", message);
            }
            self.emit("message", message);
        } else {
            self.emit("legacy", message);
        }
    }

    // Route close events as disconnect events
    function onClose(reason) {
        console.log("Smith: EngineIoTransport Close");
        self.emit("disconnect", reason);
        cleanup();
    }

    function onDrain() {
        self.emit("drain");
    }

    function onDisconnect(err) {
        console.log("Smith: EngineIoTransport Disconnect");
        self.emit("disconnect", err);
        cleanup();
    }

    socket.on("error", onError);
    socket.on("message", onMessage);
    socket.on("close", onClose);
    socket.on("drain", onDrain);
    socket.on("disconnect", onDisconnect);

    this.disconnect = function() {
        socket.close();
    };

    function cleanup() {
        socket.removeListener("error", onError);
        socket.removeListener("message", onMessage);
        socket.removeListener("close", onClose);
        socket.removeListener("drain", onDrain);
        socket.removeListener("disconnect", onDisconnect);
    }

    // Encode and route send calls to socket.
    this.send = function(message) {
        if (exports.debug && Array.isArray(message)) {
            console.log("->", message);
        }
        return socket.send(message);
    };
}

});


define('@c9/vfs-socket/api-handler', function (module, exports, require) {

// ApiHandler encapsulates logic related to vfs.extend apis:
// - stores local APIs and gives ability to call api methods.
// - creates remote APIs proxies that can be provided to clients.
// It's used by both vfs-worker and vfs-consumer.

var assert = require("assert");
var EventEmitter = require("events").EventEmitter

exports.ApiHandler = ApiHandler;

function ApiHandler(context) {
    this.context = context;
    this.apis = {};
    this.proxyApis = {};
}

ApiHandler.prototype.storeApi = function(api) {
    assert(typeof api.name === "string", "api should have 'name' property");
    assert(Array.isArray(api.names), "api should have 'names' property");
    this.apis[api.name] = api;
    return {name: api.name, names: api.names};
};

ApiHandler.prototype.callStoredApiFunction = function(apiName, fnName, args) {
    var api = this.apis[apiName];
    if (!api) return;

    var context = this.context;
    if (context.onBeforeStoredApiCall) context.onBeforeStoredApiCall(apiName, fnName, args);

    // If the last arg is a function, assume it's a callback and process it.
    if (typeof args[args.length - 1] == "function") {
        var callback = args[args.length - 1];
        args[args.length - 1] = function (err, meta) {
            if (err || (meta && typeof meta === "object")) {
                return context.processCallback(err, meta, callback);
            }
            callback(err, meta);
        };
    }

    var fun = api[fnName];

    // Defensive code, triggered by http://tt.amazon.com/0147390393
    if (!fun) {
        console.error(
            "vfs-socket/" + context.name + ".call called with apiName " + apiName
                + " and fnName " + fnName + " but no function could be found."
        );
        return;
    }

    fun.apply(api, args);
};

ApiHandler.prototype.makeApiProxy = function(token) {
    var context = this.context;
    var name = token.name;
    var api = this.proxyApis[name] = new EventEmitter();
    api.name = token.name;
    api.names = token.names;
    token.names.forEach(function(functionName) {
        api[functionName] = function() {
            var args = Array.prototype.slice.call(arguments);
            if (typeof args[args.length - 1] === "function") {
                var callback = args[args.length - 1];
                args[args.length - 1] = function (err, meta) {
                    return context.processCallback(err, meta, callback);
                };
            }
            context.remote.call(name, functionName, args);
        };
    });
    return api;
}

ApiHandler.prototype.disconnect = function() {
    Object.keys(this.proxyApis).forEach(function(name) {
        delete this.proxyApis[name];
    }.bind(this));
}

});


define('@c9/vfs-local', function (module, exports, require) {

var fs = require("fs");
var net = require("net");
var childProcess = require("child_process");
var constants = require("constants");
var join = require("path").join;
var pathResolve = require("path").resolve;
var pathNormalize = require("path").normalize;
var pathBasename = require("path").basename;
var dirname = require("path").dirname;
var basename = require("path").basename;
var Stream = require("stream").Stream;
var getMime = (function(simpleMime) {
    // workaround for a bug in simple-mime
    return function(path) {
        var mime = simpleMime(path);
        if (typeof mime != "string") return "application/octet-stream";
        return mime;
    };
})(require("simple-mime")());
var vm = require("vm");
var exists = fs.exists || require("path").exists;
var crypto = require("crypto");
var os = require("os");
var Throttle = require("stream-throttle").Throttle;
var pathSep = require("path").sep;
var transformPath;
var isWin = pathSep == "\\";

// node 0.6 does not have domain support
var domain;
try {
    domain = require("domain");
} catch (e) {}

//////////////////// windows support ///////////////////////////////////////////
if (isWin) {
    var _pathNormalize = pathNormalize;
    var _join = join;
    var _pathResolve = pathResolve;
    pathNormalize = function(p) {
        return _pathNormalize(p).replace(/[\\]/g, "/");
    };
    join = function() {
        return _join.apply(null, arguments).replace(/[\\]/g, "/");
    };
    transformPath = function(path) {
        if (path[0] == "/") {
            var m = /^\/+(\w):[\/\\]*/.exec(path);
            if (m) {
                var device = m ? m[1] : "";
                path = device + ":/" + path.substr(m[0].length).replace(/[:*?"<>|]/g, "_");
            }
        }
        return path;
    };
    pathResolve = function(path, link) {
        path = _pathResolve(path, link);
        if (path[0] !== "/") {
            path = "/" + path.replace(/[\\]/g, "/");
        }
        return path;
    };
}

// For debugging only
function logToFile(message) {
    fs.appendFile("/tmp/vfs.log", new Date().getTime() + " " + message + "\n", function(_err) {});
}

var auditLog = function(description, data) {
    console.log(description, data);
};

////////////////////////////////////////////////////////////////////////////////

module.exports = function setup(fsOptions) {
    auditLog = fsOptions.auditLog || auditLog;

    var pty;
    if (fsOptions.nodePath) {
        process.env.NODE_PATH = fsOptions.nodePath;
        require("module")._initPaths();
    }
    if (!fsOptions.nopty) {
        var modulesPath = fsOptions.nodePath || process.env.HOME + "/.c9/node_modules";
        // on darwin trying to load binary for a wrong version crashes the process
        [
            modulesPath + "/node-pty-prebuilt",
            modulesPath + "/pty.js",
            "node-pty",
            "node-pty-prebuilt",
            "@ionic/node-pty-prebuilt",
            "pty.js",
        ].some(function(p) {
            try {
                pty = require(p);
                return true;
            } catch (e) {}
        });
        if (!pty) console.warn("unable to initialize pty.js:");
    }
    if (!pty) {
        pty = function(command, options, callback) {
            console.log("PTY is not supported.");
        };
        pty.spawn = pty;
    }

    var TMUX = fsOptions.tmuxBin || "tmux";
    var BASH = fsOptions.bashBin || process.env.C9_BASH_BIN || (isWin ? "bash.exe" : "bash");
    var METAPATH = fsOptions.metapath;
    var WSMETAPATH = fsOptions.envmetapath;
    var TESTING = fsOptions.testing;
    var TMUXNAME = "cloud9";
    var noTmux;
    var tmuxWarned;

    // Check and configure options
    var root = fsOptions.root;
    if (!root) throw new Error("root is a required option");
    root = pathNormalize(root);

    if (pathSep == "/" && root[0] !== "/") throw new Error("root path must start in /");
    if (root[root.length - 1] !== "/") root += "/";

    var base = root.substr(0, root.length - 1);

    // Fetch umask
    var umask = parseInt("22", 8);
    _execFile(BASH, ["-c", "umask"], function(error, stdout, stderr) {
        if (!error && !stderr && stdout) umask = parseInt(stdout, 8);
    });

    // Fetch tmux version
    _execFile(TMUX, ["-V"], function(err, stdout) {
        if (err) stdout = "tmux 1.9";
        noTmux = err && err.code === "ENOENT";
        TMUXNAME = "cloud9" + parseFloat(stdout.replace(/tmux([-\d.]*) /, ""), 10);
    });

    if (!fsOptions.hasOwnProperty("defaultEnv")) fsOptions.defaultEnv = {};
    fsOptions.defaultEnv.__proto__ = process.env;

    // Fetch environment variables from the login shell
    var waitForEnv = null;
    if (!isWin) {
        waitForEnv = [];
        // using timeout because bash initialization may open a prompt blocking this call
        _execFile(BASH, ["-lc", "printenv -0"], {timeout: 1500}, function(error, stdout, stderr) {
            var pending = waitForEnv;
            waitForEnv = null;
            if (!error && !stderr && stdout) {
                var env = fsOptions.defaultEnv;
                stdout.split("\x00").forEach(function(entry) {
                    var i = entry.indexOf("=");
                    if (i != -1) env[entry.slice(0, i)] = entry.slice(i + 1);
                });
            }
            pending.forEach(function(x) {
                x();
            });
        });
    }

    // Storage for extension APIs
    var apis = {};
    // Storage for event handlers
    var handlers = {};

    var fileWatchers = {};

    // Export the API
    var vfs = wrapDomain({
        fsOptions: fsOptions,

        // File management
        resolve: resolve,
        stat: stat,
        readfile: readfile,
        readdir: readdir,
        mkfile: mkfile,
        mkdir: mkdir,
        mkdirP: mkdirP,
        appendfile: appendfile,
        rmfile: rmfile,
        rmdir: rmdir,
        rename: rename,
        copy: copy,
        symlink: symlink,
        chmod: chmod,

        // Set/Retrieve Metadata
        metadata: metadata,
        getMetadata: getMetadata,

        // Wrapper around fs.watch or fs.watchFile
        watch: watch,

        // Network connection
        connect: connect,

        // Process Management
        spawn: spawn,
        pty: ptyspawn,
        tmux: process.platform == "win32" ? bashspawn : tmuxspawn,
        execFile: execFile,
        killtree: killtree,

        // Basic async event emitter style API
        on: on,
        off: off,
        emit: emit,

        // Extending the API
        extend: extend,
        unextend: unextend,
        use: use,

        // Internal
        writeToWatchedFile: writeToWatchedFile,
        workspaceDir: fsOptions.projectDir,

        // State
        env: {},
    });

    function wrapDomain(api) {
        if (!domain) return api;

        for (var func in api) {
            if (typeof api[func] !== "function") continue;

            (function(func) {
                var call = api[func];
                api[func] = function() {
                    var args = Array.prototype.slice.apply(arguments);
                    var d = domain.create();
                    d.on("error", function(e) {
                        console.error("VFS Exception in function '" + func + "':\n", e.stack || e);
                        vfs.emit("error", {
                            message: e.message,
                            func: func,
                            stack: e.stack + "",
                            node: process.version,
                        });
                        console.log("Scheduling process exit");
                        setTimeout(function() {
                            console.log(
                                "Exiting after uncaught exception in '" + func + "':\n",
                                e.stack || e
                            );
                            process.exit(1);
                        }, 2000);
                    });
                    d.run(function() {
                        call.apply(api, args);
                    });
                };
            })(func);
        }
        return api;
    }

    ////////////////////////////////////////////////////////////////////////////////
    if (isWin) {
        var readSpecialDir = function(path, callback) {
            if (path == "/") {
                execFile("cmd", {args: ["/c", "wmic logicaldisk get deviceid"]}, function(
                    err,
                    result
                ) {
                    if (err) return callback(err);

                    if (result && result.stdout) {
                        var drives = result.stdout.match(/ *\w:/g).map(function(x) {
                            return x.trim();
                        });
                        var meta = {};
                        var stat = {
                            isFile: function() {
                                return false;
                            },
                            size: 0,
                            mtime: Date.now(),
                        };
                        // meta.notModified = true;
                        meta.etag = calcEtag(stat);
                        calcEtag(stat);
                        meta.stream = new Stream();
                        meta.stream.readable = true;
                        callback(null, meta);
                        drives.forEach(function(d) {
                            meta.stream.emit("data", {
                                mime: "drive/directory",
                                mtime: stat.mtime,
                                name: d,
                                size: 0,
                            });
                        });
                        meta.stream.emit("end");
                    }
                });
                return true;
            }
        };
        var isSpecialPath = function(path) {
            return path == "/";
        };
    }
    ////////////////////////////////////////////////////////////////////////////////

    function _execFile() {
        var callback = arguments[arguments.length - 1];
        try {
            return childProcess.execFile.apply(childProcess, arguments);
        } catch (e) {
            callback(e);
        }
    }

    // Realpath a file and check for access
    // callback(err, path)
    function resolvePath(path, options, callback) {
        if (!callback) {
            callback = options;
            options = {};
        }

        var alreadyRooted = options.alreadyRooted;
        var checkSymlinks = options.checkSymlinks;
        var sandbox = options.sandbox;

        if (checkSymlinks === undefined) checkSymlinks = true;

        if (!alreadyRooted) {
            if (sandbox) path = join(sandbox, path);

            path = join(root, path);
        }

        if (!options.nocheck) {
            var localRoot = sandbox ? join(root, sandbox) : root;
            var base = root.substr(0, localRoot.length - 1);
            var testPath = path.substr(0, localRoot.length);

            if (isWin) {
                testPath = testPath.toLowerCase();
                base = base.toLowerCase();
                localRoot = localRoot.toLowerCase();
            }

            if (!(path === base || testPath === localRoot)) {
                var isError = true;

                if (isError) {
                    var err = new Error("EACCES: '" + path + "' not in '" + localRoot + "'");
                    err.code = "EACCES";
                    return callback(err);
                }
            }
        }

        if (transformPath) path = transformPath(path);

        if (((checkSymlinks && fsOptions.checkSymlinks) || checkSymlinks == 2) && !alreadyRooted)
            fs.realpath(path, callback);
        else callback(null, path);
    }

    // A wrapper around fs.open that enforces permissions and gives extra data in
    // the callback. (err, path, fd, stat)
    function open(path, flags, mode, options, callback) {
        resolvePath(path, options, function(err, path) {
            if (err) return callback(err);
            fs.open(path, flags, mode, function(err, fd) {
                if (err) return callback(err);
                fs.fstat(fd, function(err, stat) {
                    if (err) return callback(err);
                    callback(null, fd, path, stat);
                });
            });
        });
    }

    // This helper function doesn't follow node conventions in the callback,
    // there is no err, only entry.
    function createStatEntry(file, fullpath, callback, _loop) {
        fs.lstat(fullpath, function(err, stat) {
            var entry = {
                name: file,
            };

            if (err) {
                entry.err = err;
                return callback(entry);
            } else {
                entry.size = stat.size;
                entry.mtime = stat.mtime.valueOf();
                entry.ctime = stat.ctime.valueOf();

                if (stat.isDirectory()) {
                    entry.mime = "inode/directory";
                } else if (stat.isBlockDevice()) entry.mime = "inode/blockdevice";
                else if (stat.isCharacterDevice()) entry.mime = "inode/chardevice";
                else if (stat.isSymbolicLink()) entry.mime = "inode/symlink";
                else if (stat.isFIFO()) entry.mime = "inode/fifo";
                else if (stat.isSocket()) entry.mime = "inode/socket";
                else {
                    entry.mime = getMime(fullpath);
                }

                if (!stat.isSymbolicLink()) {
                    return callback(entry);
                }
                fs.readlink(fullpath, function(err, link) {
                    if (err) {
                        entry.linkErr = err.stack;
                        return callback(entry);
                    }
                    var fullLinkPath = pathResolve(dirname(fullpath), link);
                    if (!_loop) {
                        _loop = {fullLinkPath: fullpath, max: 100};
                    }
                    if (
                        fullLinkPath.toLowerCase() == _loop.fullLinkPath.toLowerCase() ||
                        _loop.max-- < 0
                    ) {
                        entry.linkErr = "ELOOP: recursive symlink";
                        return callback(entry);
                    }
                    entry.link = link;
                    resolvePath(fullLinkPath, {alreadyRooted: true}, function(err, newpath) {
                        if (err) {
                            entry.linkErr = err;
                            return callback(entry);
                        }
                        createStatEntry(
                            basename(newpath),
                            newpath,
                            function(linkStat) {
                                entry.linkStat = linkStat;
                                linkStat.fullPath = newpath.substr(base.length) || "/";
                                return callback(entry);
                            },
                            _loop
                        );
                    });
                });
            }
        });
    }

    // Common logic used by rmdir and rmfile
    function remove(path, fn, options, callback) {
        var meta = {};
        resolvePath(path, options, function(err, realpath) {
            if (err) return callback(err);
            fn(realpath, function done(err) {
                if (err) {
                    if (err.code == "ENOENT") {
                        return fs.exists(realpath, function(exists) {
                            if (exists) err.code = "EACCES";
                            callback(err);
                        });
                    } else {
                        return callback(err);
                    }
                }

                // Remove metadata
                resolvePath(WSMETAPATH + path, options, function(err, realpath) {
                    if (err) return callback(null, meta);

                    fn(realpath, function() {
                        return callback(null, meta);
                    });
                });
            });
        });
    }

    ////////////////////////////////////////////////////////////////////////////////

    function resolve(path, options, callback) {
        resolvePath(path, options, function(err, path) {
            if (err) return callback(err);
            callback(null, {path: path});
        });
    }

    function stat(path, options, callback) {
        // Make sure the parent directory is accessable
        resolvePath(dirname(path), options, function(err, dir) {
            if (err) return callback(err);
            var file = basename(path);
            path = join(dir, file);
            createStatEntry(file, path, function(entry) {
                if (entry.err) {
                    return callback(entry.err);
                }
                callback(null, entry);
            });
        });
    }

    function metadata(path, options, callback) {
        if (path.charAt(0) == "~") path = join(process.env.HOME, path.substr(1));

        var dirpath =
            path.substr(0, 5) == "/_/_/"
                ? METAPATH + dirname(path.substr(4))
                : WSMETAPATH + "/" + dirname(path);

        resolvePath(dirpath, options, function(err, dir) {
            if (err) return callback(err);

            var file = basename(path);
            path = join(dir, file);
            if (pathSep === "\\") dir = dir.replace(/\\/g, "/");

            execFile("mkdir", {args: ["-p", dir]}, function(err) {
                if (err) return callback(err);
                fs.writeFile(path, JSON.stringify(options.metadata), {}, function(err) {
                    if (err) return callback(err);
                    callback(null, {});
                });
            });
        });
    }

    function resolveMetaPath(path, options, callback) {
        if (path.charAt(0) == "~") path = join(process.env.HOME, path.substr(1));

        var metaPath = join(WSMETAPATH, path);

        resolvePath(metaPath, options, function(err, path) {
            if (err) return callback(err);
            callback(null, path);
        });
    }

    function getMetadata(path, options, callback) {
        resolveMetaPath(path, options, function(err, path) {
            if (err) return callback(err);
            fs.readFile(path, callback);
        });
    }

    function readfile(path, options, callback) {
        auditLog("readfile", path);
        var meta = {};
        var originalPath = path;

        open(path, "r", parseInt("666", 8) & ~umask, options, function(err, fd, path, stat) {
            if (err) return callback(err);
            if (stat.isDirectory()) {
                fs.close(fd, function() {});
                err = new Error("EISDIR: Requested resource is a directory");
                err.code = "EISDIR";
                return callback(err);
            }

            var metadata = options.metadata && originalPath.indexOf(WSMETAPATH) == -1;

            // Basic file info
            meta.mime = getMime(path);
            meta.size = stat.size;

            calcEtagConsideringMetadata(metadata, function(err, etag) {
                if (err) return callback(err);

                meta.etag = etag;

                // ETag support
                if ((TESTING || stat.mtime % 1000) && options.etag === meta.etag) {
                    meta.notModified = true;
                    fs.close(fd, function() {});
                    return callback(null, meta);
                }

                supportRange(meta, function(_, stop) {
                    if (stop) {
                        fs.close(fd, function() {});
                        return callback(null, meta);
                    }

                    if (metadata) {
                        addMetadata(meta);
                        return;
                    }
                    done();
                });
            });

            function calcEtagConsideringMetadata(metadata, callback) {
                if (!metadata) {
                    return callback(null, calcEtag(stat));
                }

                resolveMetaPath(originalPath, options, function(err, path) {
                    if (err) return callback(null, calcEtag(stat));

                    fs.stat(path, function(err, metaStat) {
                        if (err) return callback(null, calcEtag(stat));

                        var previousMtime = stat.mtime;
                        var previousSize = stat.size;
                        var mtime = stat.mtime < metaStat.mtime ? metaStat.mtime : stat.mtime;
                        var size = parseInt(stat.size.toString() + metaStat.size.toString(), 10);
                        stat.mtime = mtime;
                        stat.size = size;
                        var etag = calcEtag(stat);
                        stat.mtime = previousMtime;
                        stat.size = previousSize;
                        callback(null, etag);
                    });
                });
            }

            function addMetadata(meta) {
                getMetadata(originalPath, options, function(err, data) {
                    if (err) return done();

                    try {
                        meta.metadataSize = data.length;
                        meta.metadataStringLength = data.toString("utf8").length;
                        done(data);
                    } catch (e) {
                        fs.close(fd, function() {});
                        done();
                    }
                });
            }

            function supportRange(meta, callback) {
                if (
                    !(
                        options.hasOwnProperty("range") &&
                        !(options.range.etag && options.range.etag !== meta.etag)
                    )
                )
                    return callback(null, false);

                var range = options.range;
                var start, end;
                if (range.hasOwnProperty("start")) {
                    start = range.start;
                    end = range.hasOwnProperty("end") ? range.end : meta.size - 1;
                } else {
                    if (range.hasOwnProperty("end")) {
                        start = meta.size - range.end;
                        end = meta.size - 1;
                    } else {
                        meta.rangeNotSatisfiable = "Invalid Range";
                        return callback(null, true);
                    }
                }
                if (end < start || start < 0 || end >= stat.size) {
                    meta.rangeNotSatisfiable = "Range out of bounds";
                    return callback(null, true);
                }
                options.start = start;
                options.end = end;
                meta.size = end - start + 1;
                meta.partialContent = {start: start, end: end, size: stat.size};
                callback(null, false);
            }

            function done(metadata) {
                // HEAD request support
                if (options.hasOwnProperty("head")) {
                    fs.close(fd, function() {});
                    return callback(null, meta);
                }

                // Read the file as a stream
                try {
                    options.fd = fd;
                    meta.stream = new fs.ReadStream(path, options);
                } catch (err) {
                    fs.close(fd, function() {});
                    return callback(err);
                }

                // Allowing downloading only 1Mb/s to avoid buffers overflowing on VFS side.
                meta.stream = meta.stream.pipe(new Throttle({rate: 1 * 1024 * 1024}));
                if (options.encoding) {
                    meta.stream.setEncoding(options.encoding);
                }
                if (metadata) {
                    var readStream = meta.stream;
                    meta.stream = new Stream();
                    meta.stream.readable = true;
                    meta.stream.writable = true;
                    meta.stream.write = function(data) {
                        meta.stream.emit("data", data);
                        return true;
                    };
                    meta.stream.end = function(data) {
                        meta.stream.emit("end", data);
                    };
                    readStream.pipe(meta.stream, {end: false});
                    readStream.on("end", function() {
                        meta.stream.write(metadata);
                        meta.stream.end();
                    });
                    meta.stream.destroy = function() {
                        readStream.destroy();
                    };
                }

                callback(null, meta);
            }
        });
    }

    function readdir(path, options, callback) {
        var meta = {};

        resolvePath(path, options, function(err, path) {
            if (err) return callback(err);
            if (isWin && readSpecialDir) {
                if (readSpecialDir(path, callback)) return;
            }
            fs.stat(path, function(err, stat) {
                if (err) return callback(err);
                if (!stat.isDirectory()) {
                    err = new Error("ENOTDIR: Requested resource is not a directory");
                    err.code = "ENOTDIR";
                    return callback(err);
                }

                // ETag support
                meta.etag = calcEtag(stat);
                if ((TESTING || stat.mtime % 1000) && options.etag === meta.etag) {
                    meta.notModified = true;
                    return callback(null, meta);
                }

                fs.readdir(path, function(err, files) {
                    if (err) return callback(err);
                    if (options.head) {
                        return callback(null, meta);
                    }
                    var stream = new Stream();
                    stream.readable = true;
                    var paused;
                    stream.pause = function() {
                        if (paused === true) return;
                        paused = true;
                    };
                    stream.resume = function() {
                        if (paused === false) return;
                        paused = false;
                        getNext();
                    };
                    meta.stream = stream;
                    callback(null, meta);
                    var index = 0;
                    var sentFilesCount = 0;
                    stream.resume();
                    function getNext() {
                        if (files.length === 0) return done();
                        if (index === files.length) return;
                        var file = files[index++];
                        var fullpath = join(path, file);

                        createStatEntry(file, fullpath, function onStatEntry(entry) {
                            stream.emit("data", entry);
                            sentFilesCount++;
                            if (sentFilesCount >= files.length) return done();

                            if (!paused) {
                                getNext();
                            }
                        });
                    }
                    function done() {
                        stream.emit("end");
                    }
                });
            });
        });
    }

    // This is used for creating / overwriting files.  It always creates a new tmp
    // file and then renames to the final destination.
    // It will copy the properties of the existing file is there is one.
    function mkfile(path, options, realCallback) {
        auditLog("mkfile", path);
        var meta = {};
        var called;
        var callback = function(err) {
            if (called) {
                if (err) {
                    if (meta.stream) meta.stream.emit("error", err);
                    else console.error(err.stack);
                } else if (meta.stream) meta.stream.emit("saved");
                return;
            }
            called = true;
            return realCallback(err, meta);
        };

        if (options.stream && !options.stream.readable) {
            return callback(new TypeError("options.stream must be readable."));
        }

        // Pause the input for now since we're not ready to write quite yet
        var readable = options.stream;
        if (readable) {
            if (readable.pause) readable.pause();
            var buffer = [];
            readable.on("data", onData);
            readable.on("end", onEnd);
        }

        var tempPath;
        var resolvedPath = "";
        var mode = options.mode || parseInt("666", 8) & ~umask;
        var createParents = options.parents;

        start();

        function onData(chunk) {
            buffer.push(["data", chunk]);
        }
        function onEnd() {
            buffer.push(["end"]);
        }
        function error(err) {
            if (!options.bufferWrite) resume();
            if (tempPath) {
                fs.unlink(tempPath, callback.bind(null, err));
            } else return callback(err);
        }

        function resume() {
            if (readable) {
                // Stop buffering events and playback anything that happened.
                readable.removeListener("data", onData);
                readable.removeListener("end", onEnd);

                buffer.forEach(function(event) {
                    readable.emit.apply(readable, event);
                });
                // Resume the input stream if possible
                if (readable.resume) readable.resume();
            }
        }

        function start() {
            resolve();
        }

        // Make sure the user has access to the directory and get the real path.
        function resolve() {
            options.checkSymlinks = 2;
            resolvePath(path, options, function(err, _resolvedPath) {
                if (err) {
                    if (err.code !== "ENOENT") {
                        return error(err);
                    }
                    // If checkSymlinks is on we'll get an ENOENT when creating a new file.
                    // In that case, just resolve the parent path and go from there.
                    resolvePath(dirname(path), options, function(err, dir) {
                        if (err && err.code === "ENOENT" && createParents) {
                            createParents = false;
                            return mkdirP(dirname(path), options, function(err) {
                                if (err) return error(err);
                                resolve();
                            });
                        }
                        if (err) return error(err);
                        resolvedPath = join(dir, basename(path));
                        createTempFile();
                    });
                    return;
                }

                resolvedPath = _resolvedPath;
                createTempFile();
            });
        }

        function createTempFile() {
            // Buffer in memory when the bufferWrite option is set to true
            if (options.bufferWrite) return bufferAndWrite();

            tempPath = tmpFile(dirname(resolvedPath), "." + basename(resolvedPath) + "-", "~");

            fs.stat(resolvedPath, create);

            function create(err, stat, isParent) {
                if (err) {
                    if (err.code === "ENOENT")
                        return fs.stat(dirname(resolvedPath), function(err, stat) {
                            create(err, stat, true);
                        });
                    return error(err);
                }

                var uid = process.getuid ? process.getuid() : 0;
                var gid = process.getgid ? process.getgid() : 0;

                if (stat) {
                    gid = stat.gid;
                    if (!isParent) {
                        mode = stat.mode & parseInt("777", 8);
                        uid = stat.uid;
                    }
                }

                // node 0.8.x adds a "wx" shortcut, but since it's not in 0.6.x we use the
                // longhand here.
                var flags = constants.O_CREAT | constants.O_WRONLY | constants.O_EXCL;
                open(tempPath, flags, mode, options, function(err, fd) {
                    if (err) return pipe();

                    fchown(fd, uid, gid, function(err) {
                        fs.close(fd, function() {});
                        if (err) {
                            fs.unlink(tempPath);
                            return pipe();
                        }

                        pipe(
                            new fs.WriteStream(tempPath, {
                                encoding: options.encoding || null,
                                mode: mode,
                            })
                        );
                    });
                });

                function fchown(fd, uid, gid, callback) {
                    fs.fstat(fd, function(err, stat) {
                        if (err) return callback(err);

                        if (stat.uid == uid && stat.gid == gid) return callback();

                        fs.fchown(fd, uid, gid, callback);
                    });
                }
            }
        }

        function bufferAndWrite() {
            var buffers = [];
            var hadError;

            readable.on("data", function(chunk) {
                buffers.push(new Buffer(chunk));
            });

            readable.on("error", function(err) {
                hadError = err;
                error(err);
            });

            readable.on("end", function(chunk) {
                if (hadError) return;

                writeToWatchedFile(resolvedPath, function(afterWrite) {
                    fs.writeFile(resolvedPath, Buffer.concat(buffers), function(err) {
                        afterWrite(function() {
                            if (err) return error(err);
                            callback();
                        });
                    });
                });
            });

            resume();
        }

        function pipe(writable) {
            var hadError;
            var swap = true;

            if (!writable) {
                swap = false;
                writable = new fs.WriteStream(resolvedPath, {
                    encoding: options.encoding || null,
                    mode: mode,
                });
            }

            if (readable) {
                readable.pipe(writable);
            } else {
                writable.on("open", function() {
                    if (hadError) return;
                    meta.stream = writable;
                    callback();
                });
            }
            writable.on("error", function(err) {
                hadError = true;
                error(err);
            });

            // intercept the first close event and perform the swap
            var emit = writable.emit;
            writable.emit = function(name) {
                var args = arguments;

                if (name !== "close") return emit.apply(writable, args);

                writable.emit = emit;

                if (!hadError) {
                    if (!swap) {
                        emit.apply(writable, args);
                        callback();
                    } else {
                        writeToWatchedFile(resolvedPath, function(afterWrite) {
                            fs.rename(tempPath, resolvedPath, function(err) {
                                afterWrite(function() {
                                    if (err) return error(err);
                                    emit.apply(writable, args);
                                    callback();
                                });
                            });
                        });
                    }
                } else {
                    emit.apply(writable, args);
                }

                return true;
            };

            resume();
        }
    }

    function mkdirP(path, options, callback) {
        resolvePath(path, {checkSymlinks: false, sandbox: options.sandbox}, function(err, dir) {
            if (err) return callback(err);

            exists(dir, function(exists) {
                if (exists) return callback(null, {});
                if (pathSep === "\\") dir = dir.replace(/\\/g, "/");

                execFile("mkdir", {args: ["-p", dir]}, function(err) {
                    if (err && err.message.indexOf("exists") > -1)
                        callback({code: "EEXIST", message: err.message});
                    else callback(null, {});
                });
            });
        });
    }

    function mkdir(path, options, callback) {
        var meta = {};

        if (options.parents) return mkdirP(path, options, callback);

        // Make sure the user has access to the parent directory and get the real path.
        resolvePath(dirname(path), options, function(err, dir) {
            if (err) return callback(err);
            path = join(dir, basename(path));
            fs.mkdir(path, function(err) {
                if (err) return callback(err);
                callback(null, meta);
            });
        });
    }

    function appendfile(path, options, callback) {
        resolvePath(path, options, function(err, resolvedPath) {
            if (err) return callback(err);
            fs.appendFile(resolvedPath, options.data, options, function(err) {
                if (err) return callback(err);
                callback(null, {});
            });
        });
    }

    function rmfile(path, options, callback) {
        auditLog("rmfile", path);
        remove(path, fs.unlink, options, callback);
    }

    function rmdir(path, options, callback) {
        auditLog("rmdir", path);
        if (options.recursive) {
            remove(
                path,
                function(path, callback) {
                    spawn("rm", {args: ["-rf", path], stdio: "ignore"}, function(err, child) {
                        if (err) return callback(err);
                        child.process.on("close", function(code) {
                            if (code) {
                                var err = new Error("Permission denied.");
                                err.code = "EACCES";
                                return callback(err);
                            }
                            callback();
                        });
                    });
                },
                options,
                callback
            );
        } else {
            remove(path, fs.rmdir, options, callback);
        }
    }

    function rename(path, options, callback) {
        auditLog("rename", path);
        var from, to;
        if (options.from) {
            from = options.from;
            to = path;
        } else if (options.to) {
            from = path;
            to = options.to;
        } else {
            return callback(new Error("Must specify either options.from or options.to"));
        }
        var meta = {};
        // Resolve path to source
        resolvePath(from, options, function(err, frompath) {
            if (err) return callback(err);
            // Resolve path to target dir
            resolvePath(dirname(to), options, function(err, dir) {
                if (err) return callback(err);
                var topath = join(dir, basename(to));

                exists(topath, function(exists) {
                    // Determine if paths are the same on a case-insensitive file system
                    // (fs.realpath and fs.stat->ino don't help here)
                    var isSamePath =
                        /darwin|^win/.test(os.platform()) &&
                        frompath.toLowerCase() === topath.toLowerCase();

                    if (!exists || options.overwrite || isSamePath) {
                        // Rename the file
                        renameWatchedFile(frompath, topath, function(err) {
                            if (err) {
                                if (err.code == "ENOENT" && options.mkdirP != false) {
                                    options.mkdirP = false;
                                    return mkdirP(dir, {}, function(err) {
                                        if (err) return callback(err);
                                        rename(path, options, callback);
                                    });
                                }
                                return callback(err);
                            }

                            if (options.metadata === false) {
                                return callback(null, meta);
                            }

                            // Rename metadata
                            var metaPath = WSMETAPATH;
                            rename(
                                metaPath + from,
                                {
                                    to: metaPath + to,
                                    metadata: false,
                                },
                                function(_err) {
                                    callback(null, meta);
                                }
                            );
                        });
                    } else {
                        var err = new Error("File already exists.");
                        err.code = "EEXIST";
                        callback(err);
                    }
                });
            });
        });
    }

    function copy(path, options, callback) {
        auditLog("copy", path);
        var from, to;
        if (options.from) {
            from = options.from;
            to = path;
        } else if (options.to) {
            from = path;
            to = options.to;
        } else {
            return callback(new Error("Must specify either options.from or options.to"));
        }

        if (!options.overwrite) {
            resolvePath(to, options, function(err, path) {
                if (err) {
                    if (err.code == "ENOENT") return innerCopy(from, to);

                    return callback(err);
                }

                fs.stat(path, function(err, stat) {
                    if (!err && stat && !stat.err) {
                        // TODO: this logic should be pushed into the application code
                        var path = to.replace(/(?:\.([\d]+))?(\.[^\.\/\\]*)?$/, function(m, d, e) {
                            return "." + (parseInt(d, 10) + 1 || 1) + (e ? e : "");
                        });

                        copy(
                            from,
                            {
                                to: path,
                                overwrite: false,
                                recursive: options.recursive,
                                sandbox: options.sandbox,
                            },
                            callback
                        );
                    } else {
                        innerCopy(from, to);
                    }
                });
            });
        } else {
            innerCopy(from, to);
        }

        function innerCopy(from, to) {
            if (options.recursive) {
                resolvePath(from, options, function(err, rFrom) {
                    if (err) return callback(err);

                    resolvePath(to, options, function(err, rTo) {
                        if (err) return callback(err);

                        spawn(
                            "cp",
                            {
                                args: ["-a", rFrom, rTo],
                                stdoutEncoding: "utf8",
                                stderrEncoding: "utf8",
                                stdinEncoding: "utf8",
                            },
                            function(err, child) {
                                if (err) return callback(err);

                                var proc = child.process;
                                var hasError;

                                proc.stderr.on("data", function(d) {
                                    if (d) {
                                        hasError = true;
                                        callback(new Error(d));
                                    }
                                });
                                proc.stdout.on("end", function() {
                                    if (!hasError) callback(null, {to: to, meta: null});
                                });
                            }
                        );
                    });
                });
            } else {
                readfile(from, {sandbox: options.sandbox}, function(err, meta) {
                    if (err) return callback(err);
                    mkfile(to, {stream: meta.stream, sandbox: options.sandbox}, function(
                        err,
                        meta
                    ) {
                        callback(err, {
                            to: to,
                            meta: meta,
                        });
                    });
                });
            }
        }
    }

    function symlink(path, options, callback) {
        auditLog("symlink", path);
        if (!options.target) return callback(new Error("options.target is required"));
        var meta = {};
        // Get real path to target dir
        resolvePath(dirname(path), options, function(err, dir) {
            if (err) return callback(err);
            path = join(dir, basename(path));

            resolvePath(options.target, options, function(err, target) {
                if (err) return callback(err);
                fs.symlink(target, path, function(err) {
                    if (err) return callback(err);
                    callback(null, meta);
                });
            });
        });
    }

    function WatcherWrapper(path, options, callback) {
        var listeners = [];
        var persistent = options.persistent;
        var timer;
        var isDir;
        var watcher;
        var _self = this;

        function watch(callback) {
            function sendError(e) {
                if (callback) return callback(e);
                else {
                    throw new Error("File does not exist");
                }
            }

            function removeFromList() {
                if (fileWatchers[path]) {
                    fileWatchers[path] = fileWatchers[path].filter(function(w) {
                        return w !== _self;
                    });
                    if (!fileWatchers[path].length) delete fileWatchers[path];
                }
            }

            try {
                removeFromList();
                fileWatchers[path] = fileWatchers[path] || [];
                fileWatchers[path].push(_self);

                if (options.file) {
                    watcher = fs.watchFile(path, {persistent: false}, onWatchEvent);
                    watcher.close = function() {
                        removeFromList();
                        fs.unwatchFile(path);
                    };
                } else {
                    watcher = fs.watch(path, {persistent: false}, onWatchEvent);
                    var close = watcher.close.bind(watcher);
                    watcher.close = function() {
                        removeFromList();
                        close();
                    };
                }

                // without this deleting folder on windows was crashing server sometimes with EPERM error
                watcher.on("error", function(e) {
                    console.error("[Watcher error]", e, path);
                });
            } catch (e) {
                return sendError(e);
            }

            callback && callback(null, _self);
        }

        function close() {
            watcher && watcher.close();
        }

        // Receives watch results, uses buffering
        function onWatchEvent(event, filename) {
            // No need to buffer if we can't expect more events
            if (persistent === false) return handleWatchEvent(event, filename);

            // 350ms buffer to see if a new event comes in,
            // and grace period where we don't rely on the watchers
            clearTimeout(timer);
            timer = setTimeout(function() {
                handleWatchEvent(event, filename);
            }, 350);

            // Continue listening
            // This timeout fixes an eternal loop that can occur with watchers
            // But we should be save the next 350ms anyway per the above
            if (event != "delete") {
                close();
                setTimeout(function() {
                    try {
                        watch();
                    } catch (e) {
                        if (e.code == "ENOENT") {
                            event = "delete";
                            sendToAllListeners(event, filename);
                            clearTimeout(timer);
                        }
                    }
                }, 15);
            }
        }

        var handleWatchEvent = (this.handleWatchEvent = function(event, filename, isVfsWrite) {
            // it is a temp file
            if (filename && filename.substr(-1) == "~" && filename.charAt(0) == ".") return;

            createStatEntry(pathBasename(path), path, function(entry) {
                entry.vfsWrite = isVfsWrite || false;

                if (entry.err) {
                    event = "delete";
                    close();
                } else if (isDir) {
                    event = "directory";

                    // This timeout helps when (for instance git) updates
                    // many files in a folder at the same time.
                    fs.readdir(path, function(err, files) {
                        if (err) {
                            event = "error";
                            return sendToAllListeners(event, filename, entry, err);
                        }

                        var latest;
                        var i = 0;
                        function statFiles() {
                            var file = files[i];
                            if (!file) return done();

                            var fullpath = join(path, file);
                            createStatEntry(file, fullpath, function(entry) {
                                files[i++] = entry;

                                if (!latest || entry.mtime > latest.mtime) latest = entry;

                                statFiles();
                            });
                        }

                        function done() {
                            // Ignore if files is tmp file
                            if (
                                latest &&
                                (latest.name.substr(-1) == "~" || latest.name[1] === "~") &&
                                latest.name.charAt(0) == "."
                            )
                                return;
                            if (latest && latest.name.match(/^__c9_invoke_/i)) return;

                            sendToAllListeners(event, filename, entry, files);
                        }

                        statFiles();
                    });
                    return;
                }

                sendToAllListeners(event, filename, entry);
            });
        });

        var sendToAllListeners = (this.sendToAllListeners = function(
            event,
            filename,
            entry,
            files
        ) {
            listeners.forEach(function(fn) {
                fn(event, filename, entry, files);
            });
        });

        this.close = function() {
            listeners = [];
            if (watcher) {
                watcher.removeListener("change", handleWatchEvent);
                watcher.close();
            }
        };

        this.on = function(name, fn) {
            if (name != "change") watcher.on.apply(watcher, arguments);
            else {
                listeners.push(fn);
            }
        };

        this.removeListener = function(name, fn) {
            if (name != "change") watcher.removeListener.apply(watcher, arguments);
            else {
                listeners.splice(listeners.indexOf(fn), 1);
            }
        };

        this.pause = function() {
            close();
        };

        this.resume = function(callback, newPath) {
            if (newPath) path = newPath;
            if (!listeners.length) return callback();
            watch(callback);
        };

        fs.stat(path, function(err, stat) {
            if (err) {
                callback(err);
                return sendToAllListeners("delete");
            }

            if (isDir === undefined) isDir = stat && stat.isDirectory();

            watch(callback);
        });
    }

    function watch(path, options, callback) {
        resolvePath(path, options, function(err, path) {
            if (isWin && isSpecialPath(path)) return callback(true);
            if (err) return callback(err);

            new WatcherWrapper(path, options, function(err, watcher) {
                if (err) return callback(err);
                callback(null, {watcher: watcher});
            });
        });
    }

    /**
     * Write to a file that may be watched by a file watcher,
     * making sure its file watching events are properly sent.
     *
     * @param {String} path                            Path of our file
     * @param {Function} callback                      Function writing to path
     * @param {Function} callback.afterWrite           Function to call when done writing
     * @param {Function} callback.afterWrite.callback  Callback of afterWrite()
     */
    function writeToWatchedFile(path, callback) {
        if (!fileWatchers[path])
            return callback(function(c) {
                c();
            });

        var watchers = fileWatchers[path].slice();

        watchers.forEach(function(w) {
            w.pause();
        });
        callback(done);

        function done(callback) {
            if (!watchers.length) return callback();

            // Notify each watcher of changes and reactivate it
            var watcher = watchers.pop();
            fs.stat(path, function(err, stat) {
                if (err || !stat) return;
                stat.vfsWrite = true;
                watcher.sendToAllListeners("change", basename(path), stat);
            });
            watcher.resume(function() {
                done(callback);
            });
        }
    }

    function renameWatchedFile(frompath, topath, callback) {
        var removed = [];
        Object.keys(fileWatchers).forEach(function(path) {
            if (
                path.slice(0, frompath.length) == frompath &&
                (path[frompath.length] == "/" || !path[frompath.length])
            ) {
                var watchers = fileWatchers[path].slice();
                watchers.forEach(function(w) {
                    w.pause();
                });
                removed.push({
                    relpath: path.slice(frompath.length),
                    watchers: watchers,
                });
            }
        });
        fs.rename(frompath, topath, function(err) {
            var root = err ? frompath : topath;
            removed.forEach(function(x) {
                var path = root + x.relpath;
                x.watchers.forEach(function(w) {
                    w.resume(function() {}, path);
                });
            });
            callback(err);
        });
    }

    function connect(port, options, callback) {
        var retries = options.hasOwnProperty("retries") ? options.retries : 5;
        var retryDelay = options.hasOwnProperty("retryDelay") ? options.retryDelay : 50;
        tryConnect();
        function tryConnect() {
            var called = false;
            var socket = net.connect(port, "127.0.0.1", function() {
                if (called) return;
                called = true;

                if (options.hasOwnProperty("encoding")) {
                    socket.setEncoding(options.encoding);
                }
                callback(null, {stream: socket});
            });
            socket.once("error", function(err) {
                if (err.code === "ECONNREFUSED" && retries) {
                    setTimeout(tryConnect, retryDelay);
                    retries--;
                    retryDelay *= 2;
                    return;
                }

                if (called) return;
                called = true;
                return callback(err);
            });
        }
    }

    function chmod(path, options, callback) {
        auditLog("chmod", path);
        resolvePath(path, options, function(err, path) {
            if (err) return callback(err);

            _execFile("chmod", [options.mode, path], {}, function(err, stdout, stderr) {
                if (err) {
                    err.stderr = stderr;
                    err.stdout = stdout;
                    return callback(err);
                }

                callback(null, {});
            });
        });
    }

    function spawn(executablePath, options, callback) {
        auditLog("spawn", executablePath);
        if (waitForEnv) return waitForEnv.push(spawn.bind(null, executablePath, options, callback));

        var args = options.args || [];

        _setDefaultEnv(options);

        resolvePath(
            executablePath,
            {
                nocheck: 1,
                alreadyRooted: true,
            },
            function(err, path) {
                if (err) return callback(err);

                var child;
                try {
                    child = childProcess.spawn(path, args, options);
                } catch (err) {
                    return callback(err);
                }

                // node 0.10.x emits error events if the file does not exist
                child.on("error", function(_err) {
                    child.emit("exit", 127);
                });

                if (!child.pid) {
                    err = new Error("spawn " + executablePath + " ENOENT");
                    err.code = "ENOENT";
                    err.errno = "ENOENT";
                    return callback(err);
                }

                if (options.resumeStdin) child.stdin.resume();
                if (options.hasOwnProperty("stdoutEncoding")) {
                    child.stdout && child.stdout.setEncoding(options.stdoutEncoding);
                }
                if (options.hasOwnProperty("stderrEncoding")) {
                    child.stderr && child.stderr.setEncoding(options.stderrEncoding);
                }

                callback(null, {
                    process: child,
                });
            }
        );
    }

    function ptyspawn(executablePath, options, callback) {
        var args = options.args || [];
        delete options.args;

        _setDefaultEnv(options);
        delete options.env.TMUX;

        if (options.testing) {
            args.forEach(function(arg, i) {
                args[i] = arg.replace(/^~/, process.env.HOME);
            });
        }

        resolvePath(
            executablePath,
            {
                nocheck: 1,
                alreadyRooted: true,
            },
            function(err, path) {
                if (err) return callback(err);

                if (options.validatePath) fs.exists(path, check);
                else check(true);

                function check(exists) {
                    if (!exists) {
                        var err = new Error("ENOENT: file not found " + path);
                        err.code = "ENOENT";
                        return callback(err);
                    }

                    var proc;
                    try {
                        proc = pty.spawn(path, args, options);
                        proc.readable = true;
                        proc.writable = true;

                        proc.on("error", function() {
                            // Prevent PTY from throwing an error;
                            // I don't know how to test and the src is funky because
                            // it tests for .length < 2. Who is setting the other event?
                        });
                        proc.resizeOrig = proc.resize;
                        proc.resize = function(cols, rows) {
                            try {
                                proc.resizeOrig(cols, rows);
                            } catch (e) {
                                console.error("error when resizing terminal", e);
                                return;
                            }
                            // todo add resize event
                            proc.emit("data", {rows: rows, cols: cols});

                            if (!tmuxWarned && !isWin) {
                                if (
                                    /v0\.([123456789]\..*|10\.(0|1|2[0-7]))/.test(process.version)
                                ) {
                                    proc.emit("data", {
                                        message: "Wrong Node.js version: " + process.version,
                                        code: "EINSTALL",
                                    });
                                } else if (TMUXNAME == "cloud91.6") {
                                    proc.emit("data", {
                                        message: "Wrong TMUX version: 1.6",
                                        code: "EINSTALL",
                                    });
                                } else if (noTmux) {
                                    proc.emit("data", {
                                        message: "Please make sure TMUX is installed",
                                        code: "EINSTALL",
                                    });
                                }
                                tmuxWarned = true;
                            }
                        };
                    } catch (err) {
                        return callback(err);
                    }

                    callback(null, {
                        pty: proc,
                    });
                }
            }
        );
    }

    function escapeRegExp(str) {
        return str.replace(/[-[\]{}()*+?.,\\^$|#\s"']/g, "\\$&");
    }

    /**
     * @param {Boolean}   [options.kill]         First kill an existing session
     * @param {Boolean}   [options.attach]       Attach if the session exists
     * @param {Boolean}   [options.detach]       Detach immediately after starting the process. This will return a pid instead of a pty.
     * @param {Boolean}   [options.detachOthers] Detach other clients immediately after starting the process
     * @param {Boolean}   [options.fetchpid]     Return the pid of the process started in the tmux session, or -1 if it's no longer running
     * @param {Boolean}   [options.output]       Act like an output pane
     * @param {Boolean}   [options.base]         The base path to store the watch files
     */
    function tmuxspawn(ignored, options, callback) {
        var tmuxName = options.tmuxName || TMUXNAME;
        var session = options.session;

        _setDefaultEnv(options);
        delete options.env.TMUX;
        function getFormatString(map) {
            return Object.keys(map)
                .filter(function(x) {
                    return x[0] == "#";
                })
                .join("\x01");
        }

        function getFormatObject(map, str) {
            var data = str.split("\x01");
            var result = {};
            Object.keys(map).forEach(function(key, i) {
                if (key[0] != "#") return;
                var val = data[i];
                if (i >= map.numberDataIndex) val = parseInt(val, 10) || 0;
                result[map[key]] = val;
            });
            return result;
        }

        function fetchPid(callback, retries) {
            if (!retries) retries = 0;
            _execFile(
                TMUX,
                [
                    "-u2",
                    "-L",
                    tmuxName,
                    "-C",
                    "list-panes",
                    "-F",
                    "c9-pid-#{pane_pid}-#{pane_dead}-#{pane_status}",
                    "-t",
                    session,
                ],
                {
                    maxBuffer: 1000 * 1024,
                    env: options.env,
                },
                function(err, stdout) {
                    var matches = /c9-pid-(\d+)-(\d)-/.exec(stdout);
                    var isDead = parseInt(matches && matches[2], 10);
                    var pid = isDead ? 0 : parseInt(matches && matches[1], 10);

                    if (!pid && !isDead && retries < 10) {
                        setTimeout(fetchPid.bind(null, callback, ++retries), 30);
                        return;
                    }

                    callback(err, {
                        pid: pid || -1,
                    });
                }
            );
        }

        // Fetch PID of a running process and return it
        if (options.fetchpid) return fetchPid(callback);

        // Capture the scrollback of a pane
        if (options.capturePane) {
            options = options.capturePane;
            args = [
                "-u2", // force utf and 256 color
                "-L",
                tmuxName,
                "capture-pane",
                options.joinLines !== false ? "-peJ" : "-pe",
                "-S",
                options.start,
                "-E",
                options.end,
                "-t",
                options.pane,
            ];

            var child;
            try {
                child = childProcess.spawn(TMUX, args, options);
            } catch (err) {
                return callback(err);
            }
            child.stdout.setEncoding("utf8");
            child.stderr.setEncoding("utf8");

            // node 0.10.x emits error events if the file does not exist
            child.on("error", function(_err) {
                child.emit("exit", 127);
            });

            callback(null, {
                process: child,
            });

            return;
        }

        if (options.listSessions) {
            args = ["-u2", "-L", tmuxName];

            var sessionFormat = {
                "#S": "name",
                "#{session_id}": "id",
                "#{session_attached}": "clientCount",
                "#{session_activity}": "activity",
                "#{session_created}": "created",
                "#{session_height}": "height",
                "#{session_width}": "width",
                numberDataIndex: 2,
            };

            args.push("list-sessions", "-F", getFormatString(sessionFormat));

            return _execFile(TMUX, args, options, function(e, data) {
                var sessions = [];
                (data || "").split("\n").forEach(function(str) {
                    if (!str) return;
                    var session = getFormatObject(sessionFormat, str);
                    sessions.push(session);
                });
                callback(e, {sessions: sessions});
            });
        } else if (options.getStatus) {
            options = options.getStatus;
            var sessionId = options.id;
            var args = ["-u2", "-L", tmuxName];

            var paneFormat = {
                "#S": "session",
                "#{pane_current_path}": "path",
                "#{pane_current_command}": "command",
                "#{pane_width}": "width",
                "#{pane_height}": "height",
                "#{history_limit}": "length",
                "#{history_size}": "line",
                "#{cursor_x}": "x",
                "#{cursor_y}": "y",
                "#{saved_cursor_x}": "savedX",
                "#{saved_cursor_y}": "savedY",
                "#{scroll_region_lower}": "scrollRegionLower",
                "#{scroll_region_upper}": "scrollRegionUpper",
                numberDataIndex: 3,
            };

            var clientFormat = {
                "#{client_session}": "session",
                "#{client_created}": "created",
                "#{client_activity}": "activity",
                "#{client_width}": "width",
                "#{client_height}": "height",
                numberDataIndex: 1,
            };

            args.push("list-panes", "-F", getFormatString(paneFormat));
            if (sessionId) args.push("-t", sessionId);
            else args.push("-a");

            if (options.listClients !== false) {
                args.push(";", "list-clients", "-F", "\n" + getFormatString(clientFormat));
                if (sessionId) args.push("-t", sessionId);
            }

            return _execFile(TMUX, args, options, function(e, data) {
                var panes = {};
                var clientsSection = false;
                (data || "").split("\n").forEach(function(str) {
                    if (!str) return (clientsSection = true);

                    var pane;
                    if (clientsSection) {
                        var client = getFormatObject(clientFormat, str);
                        pane = panes[client.session];
                        if (pane) pane.clients.push(client);
                    } else {
                        pane = getFormatObject(paneFormat, str);
                        panes[pane.session] = pane;
                        pane.clients = [];
                    }
                });
                // panes.raw = data;
                if (sessionId) panes = panes[sessionId];
                callback(e, {status: panes});
            });
        }

        // Kill the session with the same name before starting a new one
        else if (options.kill) {
            if (!options.session) return callback(new Error("Missing session name"));

            // logToFile("Kill: " + options.session);

            _execFile(
                TMUX,
                ["-L", tmuxName, "-C", "kill-session", "-t", options.session],
                options,
                function(err) {
                    if (!options.command) return callback(err, {});

                    start();
                }
            );
        }
        // Attach to a session with the same name if it exists
        else if (options.attach) {
            if (!options.session) return callback(new Error("Missing session name"));

            (function findSession(retries) {
                _execFile(TMUX, ["-u2", "-L", tmuxName, "list-sessions"], options, function(
                    err,
                    stdout
                ) {
                    if (err) stdout = ""; // This happens when the tmux server has not been started yet

                    var re = new RegExp("^" + escapeRegExp(options.session) + ":", "m");
                    if (stdout.match(re)) start(true);
                    else if (options.output && retries < 100) {
                        setTimeout(findSession.bind(null, ++retries), 10);
                    } else {
                        // var error = new Error("Session doesn't exist: " + options.session);
                        // error.code = "ENOSESSIONFOUND";
                        // callback(error);
                        start(false);
                    }
                });
            })(0);
        }
        // Just start a new session. This will fail if a session with that name already exists
        else start();

        function start(attach) {
            var args = [];

            if (!options.env) options.env = {};

            if (attach) {
                // logToFile("Attach: " + options.session);

                args = ["-u2", "-L", tmuxName, "attach", "-t", options.session];
                if (options.detachOthers) {
                    // Work around https://github.com/chjj/pty.js/issues/68
                    if (/v0\.([123456789]\..*|10\.(0|1|2[0-7]))/.test(process.version))
                        console.log("detachOthers not supported, ignoring");
                    else args.push("-d");
                }
            } else {
                // logToFile("New: " + options.session);

                args = ["-u2", "-L", tmuxName, "new", "-s", options.session];

                if (options.terminal) {
                    args.push(
                        "export ISOUTPUTPANE=0;" +
                            (options.defaultEditor
                                ? " export EDITOR='`which c9` open --wait'; "
                                : "") +
                            BASH +
                            " -l"
                    );
                } else if (options.idle) {
                    args.push(
                        BASH + ' -l -c \'printf "\\e[01;34m[Idle]\\e[0m\\n"' + "; sleep 0.1;'"
                    );
                } else if (options.command) {
                    args.push(
                        BASH +
                            " -l -c '" +
                            (
                                "trap 'printf \"\\e[01;30m\\n\\nProcess exited with code: $?\\e[0m\\n\"' EXIT\n" +
                                options.command
                            ).replace(/'/g, "'\\''") +
                            "'"
                    );
                }

                args.push(
                    ";",
                    "set",
                    "-q",
                    "-g",
                    "status",
                    "off",
                    ";",
                    "set",
                    "-q",
                    "destroy-unattached",
                    "off",
                    ";",
                    "set",
                    "-q",
                    "mouse-select-pane",
                    "on",
                    ";",
                    "set",
                    "-q",
                    "set-titles",
                    "on",
                    ";",
                    "set",
                    "-q",
                    "quiet",
                    "on",
                    ";",
                    "set",
                    "-q",
                    "-g",
                    "prefix",
                    "C-b",
                    ";",
                    "set",
                    "-q",
                    "-g",
                    "default-terminal",
                    "xterm-256color",
                    ";",
                    "setw",
                    "-q",
                    "-g",
                    "xterm-keys",
                    "on"
                );

                // disable buffering of tmux output
                // old versions of tmux skip parts of output without this flag
                if (parseFloat(TMUXNAME.substr("cloud9".length)) < 2.1)
                    args.push(";", "setw", "-q", "c0-change-trigger", "0");

                if (options.output) {
                    args.push(
                        ";",
                        "set",
                        "-q",
                        "remain-on-exit",
                        "on",
                        ";",
                        "setw",
                        "-q",
                        "-g",
                        "aggressive-resize",
                        "on"
                    );
                }

                if (options.detach && options.output) {
                    args.unshift("-C");
                    args.push(";", "list-panes", "-F", "c9-pid#{pane_pid}-");
                }
                if (options.detach) args.push(";", "detach");

                // Prevent welcome message
                options.env["ISOUTPUTPANE"] = "1";
            }

            run();

            function run(err) {
                if (err) return callback(err);

                // HACK: workaround for tmux 2.2 bug:
                // tmux passes PATH to new sessions breaking rvm
                var sep = isWin ? ";" : ":";
                options.env.PATH = options.env.PATH.split(sep)
                    .filter(function(p) {
                        return !/\/rvm\//.test(p);
                    })
                    .join(sep);
                // ENDHACK

                if (options.detach && options.output) {
                    return _execFile(
                        TMUX,
                        args,
                        {
                            args: args,
                            name: options.name,
                            cwd: options.cwd,
                            resolve: options.resolve,
                            env: options.env,
                        },
                        function(err, stdout) {
                            var m = /c9-pid(\d+)-/.exec(stdout);
                            var pid = parseInt(m && m[1], 10);
                            callback(err, {pid: pid});
                        }
                    );
                }

                ptyspawn(
                    TMUX,
                    {
                        args: args,
                        name: options.name,
                        cols: options.cols,
                        rows: options.rows,
                        cwd: options.cwd,
                        resolve: options.resolve,
                        env: options.env,
                    },
                    function(err, meta) {
                        if (err) {
                            logToFile("TMUX ERROR: " + err.message);
                            return callback(err);
                        }

                        if (!attach) {
                            meta.pty.on("data", function wait(data) {
                                if (data) meta.pty.removeListener("data", wait);
                                // Look for error states in plain text from tmux
                                if (data.indexOf("can't create socket") > -1) {
                                    var err = new Error(data);
                                    err.type = "exception";
                                    err.code = "EPERM";
                                    meta.pty.emit("data", err);
                                }
                            });
                        }

                        // Return the pty
                        callback(null, meta);

                        if (attach) meta.pty.emit("data", {started: true});
                    }
                );
            }
        }
    }

    function PtyStream(pty, isOutput, old) {
        if (old) {
            return old.attachTo(pty, isOutput);
        }
        var exited = false;

        this.readable = true;
        this.writable = true;

        this.__defineGetter__("pid", function() {
            return exited ? -1 : pty.pid;
        });

        function exit() {
            if (exited) return;

            exited = true;
            emit("data", ["\n\x1b[1mPane is dead\x1b[H"]);
            pty.kill();
            pty.kill = function() {};
        }

        this.attachTo = function(newPty) {
            pty = newPty;
            exited = false;

            this.readable = true;
            this.writable = true;

            Object.keys(events).forEach(forwardEvent);
            return this;
        };

        this.killtree = this.kill = isOutput
            ? function(signal) {
                  // We dont want to really kill, just stop the process
                  if (signal == -1) {
                      if (exited) emit("kill");
                      else {
                          exit();

                          pty.on("exit", function() {
                              emit("kill");
                          });
                      }
                      pty.suspended = true;
                      return;
                  }

                  // Otherwise we really kill this pty
                  emit("end");
                  emit("exit");
              }
            : function() {
                  pty.kill();
                  // sometimes this can be called twice from worker and from options.kill
                  // pty.js doesn't like that
                  pty.kill = function() {};
              };

        this.destroy = function() {
            return pty.destroy.apply(pty, arguments);
        };

        this.end = function() {
            return pty.end.apply(pty, arguments);
        };

        this.write = function() {
            return pty.write.apply(pty, arguments);
        };

        this.resize = function() {
            if (!exited) return pty.resize.apply(pty, arguments);
        };

        // this.acknowledgeWrite = function(callback) {
        //     setTimeout(callback, 50); // 50ms time to ack input, per Winstein and Balakrishnan, 2013
        // };

        var events = {};
        function forwardEvent(name) {
            events[name] = events[name] || [];

            if (isOutput && (name == "exit" || name == "close" || name == "end")) {
                if (name != "exit") return;

                pty.on("exit", function() {
                    exit();
                });
            } else {
                pty.on(name, function() {
                    emit(name, arguments);
                });
            }
        }

        function emit(name, args) {
            if (!events[name]) return;

            events[name].forEach(function(fn) {
                fn.apply(pty, args);
            });
        }

        this.on = this.addListener = function(name, fn) {
            if (!events[name]) forwardEvent(name);
            events[name].push(fn);
        };

        this.off = this.removeListener = function(name, fn) {
            var idx = events[name].indexOf(fn);
            if (idx > -1) events[name].splice(idx, 1);
        };

        this.emit = emit;
    }

    // Same as tmuxspawn but than spawns bash or other shell, for windows
    var sessions = {};
    function bashspawn(ignored, options, callback) {
        var session;

        function getSessionId() {
            var id = "session" + Math.round(Math.random() * 1000);
            return sessions[id] ? getSessionId() : id;
        }

        // Fetch PID of a running process and return it
        if (options.fetchpid) {
            session = sessions[options.session];
            setTimeout(function() {
                callback(null, {pid: session && session.pty ? session.pty.pid : -1});
            }, 100); // workaround for late exit message from winpty
            return;
        }

        // Capture the scrollback of a pane
        if (options.capturePane) return callback(new Error("Not Supported on Windows"));

        // Kill the session with the same name before starting a new one
        if (options.kill) {
            session = sessions[options.session];
            if (session && session.pty) session.pty.kill();

            if (!options.command)
                return callback(session ? null : new Error("No Session Found"), {});

            start();
        }
        // Attach to a session with the same name if it exists
        else if (options.attach) {
            if (!options.session) return callback(new Error("Missing session name"));

            session = sessions[options.session];
            if (session) {
                if (session.wait) session.wait.push(callback);
                else if (session.pty && !session.pty.suspended) callback(null, {pty: session.pty});
            } else start();
        }
        // Just start a new session. This will fail if a session with that name already exists
        else {
            if (options.session && sessions[options.session]) {
                callback(new Error("Session Already Started"));
            }

            start();
        }

        function start() {
            if (!options.session) return callback(new Error("Missing session name"));

            var args = ["-l", "-i"];
            var name = options.session || getSessionId();

            var session = sessions[name] || {};
            sessions[name] = session;
            if (!session.wait) session.wait = [];

            if (options.idle) {
                options.command = "echo '\x1b[2J\x1b[1;1H\x1b[01;34m[Idle]\x1b[0m'";
            } else if (options.command) {
                options.command =
                    "echo '\x1b[2J\x1b[1;1H';" +
                    options.command +
                    ';printf "\x1b[01;30m\n\nProcess exited with code: $?\x1b[0m\n"';
            }

            if (options.command) {
                args.push("-c", (isWin ? "nodosfilewarning=1;" : "") + options.command);
            }

            run();

            function run(err) {
                if (err) return callback(err);

                // Start PTY with TMUX
                ptyspawn(
                    options.BASH || BASH,
                    {
                        args: args,
                        name: options.name,
                        cols: options.cols,
                        rows: options.rows,
                        cwd: options.cwd,
                        resolve: options.resolve,
                        env: options.env || {},
                    },
                    function(err, meta) {
                        if (err) return callback(err);

                        session.pty = meta.pty = new PtyStream(
                            meta.pty,
                            options.output,
                            session.pty
                        );

                        var wait = session.wait;
                        delete session.wait;
                        wait.forEach(function(callback) {
                            callback(null, {pty: session.pty});
                        });

                        // Clear Session when pty ends
                        meta.pty.on("exit", function() {
                            delete sessions[name];
                        });

                        // Fetch the PID if appropriate
                        if (options.detach && options.output) {
                            session.pty.on("data", function wait(data) {
                                // if (data.indexOf("aggressive-resize") > -1) {

                                session.pid = meta.pid = session.pty.pid;
                                callback(null, meta);

                                session.pty.removeListener("data", wait);
                                // }
                            });
                            return;
                        }

                        // Return the pty
                        callback(null, meta);
                    }
                );
            }
        }
    }

    function execFile(executablePath, options, callback) {
        auditLog("execFile", executablePath);
        if (waitForEnv)
            return waitForEnv.push(execFile.bind(null, executablePath, options, callback));

        if (isWin && execFileWin(executablePath, options, callback)) return;

        _setDefaultEnv(options);

        resolvePath(
            executablePath,
            {
                nocheck: 1,
                alreadyRooted: true,
            },
            function(err, path) {
                if (err) return callback(err);

                _execFile(path, options.args || [], options, function(err, stdout, stderr) {
                    if (err) {
                        err.stderr = stderr;
                        err.stdout = stdout;
                        return callback(err);
                    }

                    callback(null, {
                        stdout: stdout,
                        stderr: stderr,
                    });
                });
            }
        );
    }

    function execFileWin(executablePath, options, callback) {
        if (executablePath == "kill") {
            var pid = options.args && options.args[0];

            Object.keys(sessions).some(function(key) {
                if (sessions[key].pid == pid && sessions[key].pty) {
                    sessions[key].pty.killtree(-1);
                    return true;
                }
            });
            callback();
            return true;
        }
    }

    function _setDefaultEnv(options) {
        if (options.hasOwnProperty("env")) options.env.__proto__ = fsOptions.defaultEnv;
        else options.env = fsOptions.defaultEnv;

        // Pty is only reading from the object itself;
        var env = {};
        for (var prop in options.env) env[prop] = options.env[prop];
        options.env = env;

        if (options.cwd && options.cwd.charAt(0) == "~")
            options.cwd = options.env.HOME + options.cwd.substr(1);

        if (transformPath && options.cwd) options.cwd = transformPath(options.cwd);
    }

    function killtree(pid, options, callback) {
        var code = options.code || options.graceful ? "SIGTERM" : "SIGKILL";

        childrenOfPid(pid, function killList(err, pidlist) {
            if (err) return callback(err);

            pidlist.forEach(function(pid) {
                // if asked to kill ourselves do that only after killing all the children
                if (pid == process.pid) {
                    return setTimeout(function() {
                        process.kill(pid, code);
                    });
                }
                try {
                    process.kill(pid, code);
                } catch (e) {
                    if (e.code == "ESRCH") return; // kill may throw if the pid does not exist.
                    // todo try killing with sudo in case of "EPERM"
                }
            });
            if (options.graceful && code != "SIGKILL") {
                code = "SIGKILL";
                setTimeout(function() {
                    killList(null, pidlist);
                }, options.timeout || 800);
            } else {
                callback(null, {});
            }
        });
    }

    function childrenOfPid(pid, callback) {
        if (isWin) return callback(null, [pid]);

        _execFile("ps", ["-A", "-oppid,pid"], function(err, stdout, stderr) {
            if (err) return callback(err);

            var parents = {};
            stdout
                .split("\n")
                .slice(1)
                .forEach(function(line) {
                    var col = line.trim().split(/\s+/g);
                    (parents[col[0]] || (parents[col[0]] = [])).push(parseInt(col[1], 10));
                });

            function search(roots) {
                var res = roots.concat();
                for (var i = 0; i < roots.length; i++) {
                    var c = parents[roots[i]];
                    if (c) res.push.apply(res, search(c));
                }
                return res;
            }
            callback(null, search([pid]));
        });
    }

    function on(name, handler, callback) {
        if (!handlers[name]) handlers[name] = [];
        handlers[name].push(handler);
        callback && callback();
    }

    function off(name, handler, callback) {
        var list = handlers[name];
        if (list) {
            var index = list.indexOf(handler);
            if (index >= 0) {
                list.splice(index, 1);
            }
        }
        callback && callback();
    }

    function emit(name, value, callback) {
        var list = handlers[name];
        if (list) {
            for (var i = 0, l = list.length; i < l; i++) {
                list[i](value);
            }
        }
        callback && callback();
    }

    function extend(name, options, callback) {
        if (!name) {
            var err = new Error("EACCES: Invalid extension name");
            err.code = "EACCES";
            return callback(err);
        }

        var meta = {};
        // Pull from cache if it's already loaded.
        if (!options.redefine && apis.hasOwnProperty(name)) {
            err = new Error("EEXIST: Extension API already defined for " + name);
            err.code = "EEXIST";
            return callback(err, {api: apis[name]});
        }

        if (options.redefine && apis[name] && apis[name].destroy) apis[name].destroy();

        var fn;

        // The user can pass in a path to a file to require
        if (options.file) {
            try {
                fn = require(options.file);
            } catch (err) {
                console.error("vfs.extend failed for file" + options.file + ": ", err);
                return callback(err);
            }
            exec(fn);
        }

        // User can pass in code as a pre-buffered string
        else if (options.code) {
            try {
                fn = evaluate(options.code, name);
            } catch (err) {
                console.error("vfs.extend failed for code" + options.code + ": ", err);
                return callback(err);
            }
            exec(fn);
        }

        // Or they can provide a readable stream
        else if (options.stream) {
            consumeStream(options.stream, function(err, code) {
                if (err) {
                    console.error("vfs.extend failed for stream" + options.stream + ": ", err);
                    return callback(err);
                }
                var fn;
                try {
                    fn = evaluate(code);
                } catch (err) {
                    console.error("extend evaluation failed", err);
                    return callback(err);
                }
                exec(fn);
            });
        } else {
            return callback(
                new Error(
                    "must provide `file`, `code`, or `stream` when cache is empty for " + name
                )
            );
        }

        function exec(fn) {
            delete options.code;
            delete options.stream;
            delete options.file;

            fn(vfs, options, function(err, exports) {
                if (err) {
                    console.error("extend execution failed", err);
                    return callback(err);
                }
                exports.names = Object.keys(exports);
                exports.name = name;

                wrapDomain(exports);

                if (exports.on)
                    console.warn(
                        "Warning: " + name + " exports 'on' symbol that will be overwritten"
                    );
                apis[name] = exports;
                meta.api = exports;
                callback(null, meta);
            });
        }
    }

    function unextend(name, options, callback) {
        if (apis[name] && apis[name].destroy) apis[name].destroy();

        delete apis[name];
        callback(null, {});
    }

    function use(name, options, callback) {
        var api = apis[name];
        if (!api) {
            var err = new Error("ENOENT: There is no API extension named " + name);
            err.code = "ENOENT";
            return callback(err);
        }
        callback(null, {api: api});
    }

    ////////////////////////////////////////////////////////////////////////////////

    if (fsOptions.extendApi) {
        for (var i in fsOptions.extendApi) {
            extend(i, fsOptions.extendApi[i], function() {});
        }
    }

    return vfs;
};

// Consume all data in a readable stream and call callback with full buffer.
function consumeStream(stream, callback) {
    var chunks = [];
    stream.on("data", onData);
    stream.on("end", onEnd);
    stream.on("error", onError);
    function onData(chunk) {
        chunks.push(chunk);
    }
    function onEnd() {
        cleanup();
        callback(null, chunks.join(""));
    }
    function onError(err) {
        cleanup();
        callback(err);
    }
    function cleanup() {
        stream.removeListener("data", onData);
        stream.removeListener("end", onEnd);
        stream.removeListener("error", onError);
    }
}

// node-style eval
function evaluate(code, name) {
    var exports = {};
    var module = {exports: exports};
    var fn = vm.runInThisContext(
        "(function(require, exports, module, __dirname, __filename) {" + code + "})",
        name || "dynamic-" + Date.now().toString(36)
    );
    fn(require, exports, module, "", "");
    return module.exports;
}

// Calculate a proper etag from a nodefs stat object
function calcEtag(stat) {
    return (
        (stat.isFile() ? "" : "W/") +
        '"' +
        (stat.ino || 0).toString(36) +
        "-" +
        stat.size.toString(36) +
        "-" +
        stat.mtime.valueOf().toString(36) +
        '"'
    );
}

function uid(length) {
    return crypto
        .randomBytes(length)
        .toString("base64")
        .slice(0, length)
        .replace(/[+\/]+/g, "");
}

function tmpFile(baseDir, prefix, suffix) {
    return join(baseDir, [prefix || "", uid(20), suffix || ""].join(""));
}

});


define('simple-mime', function (module, exports, require) {

// A simple mime database.
var types;
module.exports = function setup(defaultMime) {
  return function getMime(path) {
    path = path.toLowerCase().trim();
    var index = path.lastIndexOf("/");
    if (index >= 0) {
      path = path.substr(index + 1);
    }
    index = path.lastIndexOf(".");
    if (index >= 0) {
      path = path.substr(index + 1);
    }
    return types[path] || defaultMime;
  };
};

// Borrowed and passed around from who knows where, last grabbed from connect.
types = {
  "3gp": "video/3gpp",
  a: "application/octet-stream",
  ai: "application/postscript",
  aif: "audio/x-aiff",
  aiff: "audio/x-aiff",
  asc: "application/pgp-signature",
  asf: "video/x-ms-asf",
  asm: "text/x-asm",
  asx: "video/x-ms-asf",
  atom: "application/atom+xml",
  au: "audio/basic",
  avi: "video/x-msvideo",
  bat: "application/x-msdownload",
  bin: "application/octet-stream",
  bmp: "image/bmp",
  bz2: "application/x-bzip2",
  c: "text/x-csrc",
  cab: "application/vnd.ms-cab-compressed",
  can: "application/candor",
  cc: "text/x-c++src",
  chm: "application/vnd.ms-htmlhelp",
  "class": "application/octet-stream",
  com: "application/x-msdownload",
  conf: "text/plain",
  cpp: "text/x-c",
  crt: "application/x-x509-ca-cert",
  css: "text/css",
  csv: "text/csv",
  cxx: "text/x-c",
  deb: "application/x-debian-package",
  der: "application/x-x509-ca-cert",
  diff: "text/x-diff",
  djv: "image/vnd.djvu",
  djvu: "image/vnd.djvu",
  dll: "application/x-msdownload",
  dmg: "application/octet-stream",
  doc: "application/msword",
  dot: "application/msword",
  dtd: "application/xml-dtd",
  dvi: "application/x-dvi",
  ear: "application/java-archive",
  eml: "message/rfc822",
  eps: "application/postscript",
  exe: "application/x-msdownload",
  f: "text/x-fortran",
  f77: "text/x-fortran",
  f90: "text/x-fortran",
  flv: "video/x-flv",
  "for": "text/x-fortran",
  gem: "application/octet-stream",
  gemspec: "text/x-script.ruby",
  gif: "image/gif",
  gyp: "text/x-script.python",
  gypi: "text/x-script.python",
  gz: "application/x-gzip",
  h: "text/x-chdr",
  hh: "text/x-c++hdr",
  htm: "text/html",
  html: "text/html",
  ico: "image/vnd.microsoft.icon",
  ics: "text/calendar",
  ifb: "text/calendar",
  iso: "application/octet-stream",
  jar: "application/java-archive",
  java: "text/x-java-source",
  jnlp: "application/x-java-jnlp-file",
  jpeg: "image/jpeg",
  jpg: "image/jpeg",
  js: "application/javascript",
  json: "application/json",
  less: "text/css",
  log: "text/plain",
  lua: "text/x-script.lua",
  luac: "application/x-bytecode.lua",
  makefile: "text/x-makefile",
  m3u: "audio/x-mpegurl",
  m4v: "video/mp4",
  man: "text/troff",
  manifest: "text/cache-manifest",
  markdown: "text/x-markdown",
  mathml: "application/mathml+xml",
  mbox: "application/mbox",
  mdoc: "text/troff",
  md: "text/x-markdown",
  me: "text/troff",
  mid: "audio/midi",
  midi: "audio/midi",
  mime: "message/rfc822",
  mml: "application/mathml+xml",
  mng: "video/x-mng",
  mov: "video/quicktime",
  mp3: "audio/mpeg",
  mp4: "video/mp4",
  mp4v: "video/mp4",
  mpeg: "video/mpeg",
  mpg: "video/mpeg",
  ms: "text/troff",
  msi: "application/x-msdownload",
  odp: "application/vnd.oasis.opendocument.presentation",
  ods: "application/vnd.oasis.opendocument.spreadsheet",
  odt: "application/vnd.oasis.opendocument.text",
  ogg: "application/ogg",
  p: "text/x-pascal",
  pas: "text/x-pascal",
  pbm: "image/x-portable-bitmap",
  pdf: "application/pdf",
  pem: "application/x-x509-ca-cert",
  pgm: "image/x-portable-graymap",
  pgp: "application/pgp-encrypted",
  pkg: "application/octet-stream",
  pl: "text/x-script.perl",
  pm: "text/x-script.perl-module",
  png: "image/png",
  pnm: "image/x-portable-anymap",
  ppm: "image/x-portable-pixmap",
  pps: "application/vnd.ms-powerpoint",
  ppt: "application/vnd.ms-powerpoint",
  ps: "application/postscript",
  psd: "image/vnd.adobe.photoshop",
  py: "text/x-script.python",
  qt: "video/quicktime",
  ra: "audio/x-pn-realaudio",
  rake: "text/x-script.ruby",
  ram: "audio/x-pn-realaudio",
  rar: "application/x-rar-compressed",
  rb: "text/x-script.ruby",
  rdf: "application/rdf+xml",
  roff: "text/troff",
  rpm: "application/x-redhat-package-manager",
  rss: "application/rss+xml",
  rtf: "application/rtf",
  ru: "text/x-script.ruby",
  s: "text/x-asm",
  sgm: "text/sgml",
  sgml: "text/sgml",
  sh: "application/x-sh",
  sig: "application/pgp-signature",
  snd: "audio/basic",
  so: "application/octet-stream",
  svg: "image/svg+xml",
  svgz: "image/svg+xml",
  swf: "application/x-shockwave-flash",
  t: "text/troff",
  tar: "application/x-tar",
  tbz: "application/x-bzip-compressed-tar",
  tci: "application/x-topcloud",
  tcl: "application/x-tcl",
  tex: "application/x-tex",
  texi: "application/x-texinfo",
  texinfo: "application/x-texinfo",
  text: "text/plain",
  tif: "image/tiff",
  tiff: "image/tiff",
  torrent: "application/x-bittorrent",
  tr: "text/troff",
  ttf: "application/x-font-ttf",
  txt: "text/plain",
  vcf: "text/x-vcard",
  vcs: "text/x-vcalendar",
  vrml: "model/vrml",
  war   : "application/java-archive",
  wav   : "audio/x-wav",
  webapp: "application/x-web-app-manifest+json",
  webm: "video/webm",
  wma: "audio/x-ms-wma",
  wmv: "video/x-ms-wmv",
  wmx: "video/x-ms-wmx",
  wrl: "model/vrml",
  wsdl: "application/wsdl+xml",
  xbm: "image/x-xbitmap",
  xhtml: "application/xhtml+xml",
  xls: "application/vnd.ms-excel",
  xml: "application/xml",
  xpm: "image/x-xpixmap",
  xsl: "application/xml",
  xslt: "application/xslt+xml",
  yaml: "text/yaml",
  yml: "text/yaml",
  zip: "application/zip"
};

});


define('stream-throttle', function (module, exports, require) {

module.exports = require('./src/throttle.js');

});


define('stream-throttle/src/throttle.js', function (module, exports, require) {

var inherits = require('util').inherits;
var Transform = require('stream').Transform;
var TokenBucket = require('limiter').TokenBucket;

/*
 * Throttle is a throttled stream implementing the stream.Transform interface.
 * Options:
 *    rate (mandatory): the throttling rate in bytes per second.
 *    chunksize (optional): the maximum chunk size into which larger writes are decomposed.
 * Any other options are passed to stream.Transform.
 */
function Throttle(opts, group) {
    if (group === undefined)
        group = new ThrottleGroup(opts);
    this.bucket = group.bucket;
    this.chunksize = group.chunksize;
    Transform.call(this, opts);
}
inherits(Throttle, Transform);

Throttle.prototype._transform = function(chunk, encoding, done) {
    process(this, chunk, 0, done);
};

function process(self, chunk, pos, done) {
    var slice = chunk.slice(pos, pos + self.chunksize);
    if (!slice.length) {
        // chunk fully consumed
        done();
        return;
    }
    self.bucket.removeTokens(slice.length, function(err) {
        if (err) {
            done(err);
            return;
        }
        self.push(slice);
        process(self, chunk, pos + self.chunksize, done);
    });
}

/*
 * ThrottleGroup throttles an aggregate of streams.
 * Options are the same as for Throttle.
 */
function ThrottleGroup(opts) {
    if (!(this instanceof ThrottleGroup))
        return new ThrottleGroup(opts);

    opts = opts || {};
    if (opts.rate === undefined)
        throw new Error('throttle rate is a required argument');
    if (typeof opts.rate !== 'number' || opts.rate <= 0)
        throw new Error('throttle rate must be a positive number');
    if (opts.chunksize !== undefined && (typeof opts.chunksize !== 'number' || opts.chunksize <= 0)) {
        throw new Error('throttle chunk size must be a positive number');
    }

    this.rate = opts.rate;
    this.chunksize = opts.chunksize || this.rate/10;
    this.bucket = new TokenBucket(this.rate, this.rate, 'second', null);
}

/*
 * Create a new stream in the throttled group and returns it.
 * Any supplied options are passed to the Throttle constructor.
 */
ThrottleGroup.prototype.throttle = function(opts) {
    return new Throttle(opts, this);
};

module.exports = {
    Throttle: Throttle,
    ThrottleGroup: ThrottleGroup
};
});


define('limiter', function (module, exports, require) {


exports.RateLimiter = require('./lib/rateLimiter');
exports.TokenBucket = require('./lib/tokenBucket');

});


define('limiter/lib/rateLimiter', function (module, exports, require) {

var TokenBucket = require('./tokenBucket');
var getMilliseconds = require('./clock');

/**
 * A generic rate limiter. Underneath the hood, this uses a token bucket plus
 * an additional check to limit how many tokens we can remove each interval.
 * @author John Hurliman <jhurliman@jhurliman.org>
 *
 * @param {Number} tokensPerInterval Maximum number of tokens that can be
 *  removed at any given moment and over the course of one interval.
 * @param {String|Number} interval The interval length in milliseconds, or as
 *  one of the following strings: 'second', 'minute', 'hour', day'.
 * @param {Boolean} fireImmediately Optional. Whether or not the callback
 *  will fire immediately when rate limiting is in effect (default is false).
 */
var RateLimiter = function(tokensPerInterval, interval, fireImmediately) {
  this.tokenBucket = new TokenBucket(tokensPerInterval, tokensPerInterval,
    interval, null);

  // Fill the token bucket to start
  this.tokenBucket.content = tokensPerInterval;

  this.curIntervalStart = getMilliseconds();
  this.tokensThisInterval = 0;
  this.fireImmediately = fireImmediately;
};

RateLimiter.prototype = {
  tokenBucket: null,
  curIntervalStart: 0,
  tokensThisInterval: 0,
  fireImmediately: false,

  /**
   * Remove the requested number of tokens and fire the given callback. If the
   * rate limiter contains enough tokens and we haven't spent too many tokens
   * in this interval already, this will happen immediately. Otherwise, the
   * removal and callback will happen when enough tokens become available.
   * @param {Number} count The number of tokens to remove.
   * @param {Function} callback(err, remainingTokens)
   * @returns {Boolean} True if the callback was fired immediately, otherwise
   *  false.
   */
  removeTokens: function(count, callback) {
    // Make sure the request isn't for more than we can handle
    if (count > this.tokenBucket.bucketSize) {
      process.nextTick(callback.bind(null, 'Requested tokens ' + count +
        ' exceeds maximum tokens per interval ' + this.tokenBucket.bucketSize,
        null));
      return false;
    }

    var self = this;
    var now = getMilliseconds();

    // Advance the current interval and reset the current interval token count
    // if needed
    if (now < this.curIntervalStart
      || now - this.curIntervalStart >= this.tokenBucket.interval) {
      this.curIntervalStart = now;
      this.tokensThisInterval = 0;
    }

    // If we don't have enough tokens left in this interval, wait until the
    // next interval
    if (count > this.tokenBucket.tokensPerInterval - this.tokensThisInterval) {
      if (this.fireImmediately) {
        process.nextTick(callback.bind(null, null, -1));
      } else {
        var waitInterval = Math.ceil(
          this.curIntervalStart + this.tokenBucket.interval - now);

        setTimeout(function() {
          self.tokenBucket.removeTokens(count, afterTokensRemoved);
        }, waitInterval);
      }
      return false;
    }

    // Remove the requested number of tokens from the token bucket
    return this.tokenBucket.removeTokens(count, afterTokensRemoved);

    function afterTokensRemoved(err, tokensRemaining) {
      if (err) return callback(err, null);

      self.tokensThisInterval += count;
      callback(null, tokensRemaining);
    }
  },

  /**
   * Attempt to remove the requested number of tokens and return immediately.
   * If the bucket (and any parent buckets) contains enough tokens and we
   * haven't spent too many tokens in this interval already, this will return
   * true. Otherwise, false is returned.
   * @param {Number} count The number of tokens to remove.
   * @param {Boolean} True if the tokens were successfully removed, otherwise
   *  false.
   */
  tryRemoveTokens: function(count) {
    // Make sure the request isn't for more than we can handle
    if (count > this.tokenBucket.bucketSize)
      return false;

    var now = getMilliseconds();

    // Advance the current interval and reset the current interval token count
    // if needed
    if (now < this.curIntervalStart
      || now - this.curIntervalStart >= this.tokenBucket.interval) {
      this.curIntervalStart = now;
      this.tokensThisInterval = 0;
    }

    // If we don't have enough tokens left in this interval, return false
    if (count > this.tokenBucket.tokensPerInterval - this.tokensThisInterval)
      return false;

    // Try to remove the requested number of tokens from the token bucket
    var removed = this.tokenBucket.tryRemoveTokens(count);
    if (removed) {
      this.tokensThisInterval += count;
    }
    return removed;
  },

  /**
   * Returns the number of tokens remaining in the TokenBucket.
   * @returns {Number} The number of tokens remaining.
   */
  getTokensRemaining: function () {
    this.tokenBucket.drip();
    return this.tokenBucket.content;
  }
};

module.exports = RateLimiter;

});


define('limiter/lib/tokenBucket', function (module, exports, require) {


/**
 * A hierarchical token bucket for rate limiting. See
 * http://en.wikipedia.org/wiki/Token_bucket for more information.
 * @author John Hurliman <jhurliman@cull.tv>
 *
 * @param {Number} bucketSize Maximum number of tokens to hold in the bucket.
 *  Also known as the burst rate.
 * @param {Number} tokensPerInterval Number of tokens to drip into the bucket
 *  over the course of one interval.
 * @param {String|Number} interval The interval length in milliseconds, or as
 *  one of the following strings: 'second', 'minute', 'hour', day'.
 * @param {TokenBucket} parentBucket Optional. A token bucket that will act as
 *  the parent of this bucket.
 */
var TokenBucket = function(bucketSize, tokensPerInterval, interval, parentBucket) {
  this.bucketSize = bucketSize;
  this.tokensPerInterval = tokensPerInterval;

  if (typeof interval === 'string') {
    switch (interval) {
      case 'sec': case 'second':
        this.interval = 1000; break;
      case 'min': case 'minute':
        this.interval = 1000 * 60; break;
      case 'hr': case 'hour':
        this.interval = 1000 * 60 * 60; break;
      case 'day':
        this.interval = 1000 * 60 * 60 * 24; break;
      default:
        throw new Error('Invaid interval ' + interval);
    }
  } else {
    this.interval = interval;
  }

  this.parentBucket = parentBucket;
  this.content = 0;
  this.lastDrip = +new Date();
};

TokenBucket.prototype = {
  bucketSize: 1,
  tokensPerInterval: 1,
  interval: 1000,
  parentBucket: null,
  content: 0,
  lastDrip: 0,

  /**
   * Remove the requested number of tokens and fire the given callback. If the
   * bucket (and any parent buckets) contains enough tokens this will happen
   * immediately. Otherwise, the removal and callback will happen when enough
   * tokens become available.
   * @param {Number} count The number of tokens to remove.
   * @param {Function} callback(err, remainingTokens)
   * @returns {Boolean} True if the callback was fired immediately, otherwise
   *  false.
   */
  removeTokens: function(count, callback) {
    var self = this;

    // Is this an infinite size bucket?
    if (!this.bucketSize) {
      process.nextTick(callback.bind(null, null, count, Number.POSITIVE_INFINITY));
      return true;
    }

    // Make sure the bucket can hold the requested number of tokens
    if (count > this.bucketSize) {
      process.nextTick(callback.bind(null, 'Requested tokens ' + count + ' exceeds bucket size ' +
        this.bucketSize, null));
      return false;
    }

    // Drip new tokens into this bucket
    this.drip();

    // If we don't have enough tokens in this bucket, come back later
    if (count > this.content)
      return comeBackLater();

    if (this.parentBucket) {
      // Remove the requested from the parent bucket first
      return this.parentBucket.removeTokens(count, function(err, remainingTokens) {
        if (err) return callback(err, null);

        // Check that we still have enough tokens in this bucket
        if (count > self.content)
          return comeBackLater();

        // Tokens were removed from the parent bucket, now remove them from
        // this bucket and fire the callback. Note that we look at the current
        // bucket and parent bucket's remaining tokens and return the smaller
        // of the two values
        self.content -= count;
        callback(null, Math.min(remainingTokens, self.content));
      });
    } else {
      // Remove the requested tokens from this bucket and fire the callback
      this.content -= count;
      process.nextTick(callback.bind(null, null, this.content));
      return true;
    }

    function comeBackLater() {
      // How long do we need to wait to make up the difference in tokens?
      var waitInterval = Math.ceil(
        (count - self.content) * (self.interval / self.tokensPerInterval));
      setTimeout(function() { self.removeTokens(count, callback); }, waitInterval);
      return false;
    }
  },

  /**
   * Attempt to remove the requested number of tokens and return immediately.
   * If the bucket (and any parent buckets) contains enough tokens this will
   * return true, otherwise false is returned.
   * @param {Number} count The number of tokens to remove.
   * @param {Boolean} True if the tokens were successfully removed, otherwise
   *  false.
   */
  tryRemoveTokens: function(count) {
    // Is this an infinite size bucket?
    if (!this.bucketSize)
      return true;

    // Make sure the bucket can hold the requested number of tokens
    if (count > this.bucketSize)
      return false;

    // Drip new tokens into this bucket
    this.drip();

    // If we don't have enough tokens in this bucket, return false
    if (count > this.content)
      return false;

    // Try to remove the requested tokens from the parent bucket
    if (this.parentBucket && !this.parentBucket.tryRemoveTokens(count))
      return false;

    // Remove the requested tokens from this bucket and return
    this.content -= count;
    return true;
  },

  /**
   * Add any new tokens to the bucket since the last drip.
   * @returns {Boolean} True if new tokens were added, otherwise false.
   */
  drip: function() {
    if (!this.tokensPerInterval) {
      this.content = this.bucketSize;
      return;
    }

    var now = +new Date();
    var deltaMS = Math.max(now - this.lastDrip, 0);
    this.lastDrip = now;

    var dripAmount = deltaMS * (this.tokensPerInterval / this.interval);
    this.content = Math.min(this.content + dripAmount, this.bucketSize);
  }
};

module.exports = TokenBucket;

});


define('limiter/lib/clock', function (module, exports, require) {

var getMilliseconds = function() {
  if (typeof process !== 'undefined' && process.hrtime) {
    var hrtime = process.hrtime();
    var seconds = hrtime[0];
    var nanoseconds = hrtime[1];

    return seconds * 1e3 +  Math.floor(nanoseconds / 1e6);
  }

  return new Date().getTime();
}

module.exports = getMilliseconds;

});
